{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport { DefaultIssuerResolver as e, DefaultWebFingerResolver as t, DefaultIPFSResolver as r } from \"@uauth/common\";\nimport { Resolution as n, ResolutionError as o, ResolutionErrorCode as i } from \"@unstoppabledomains/resolution\";\nimport s from \"global\";\nimport { jwtVerify as u, createRemoteJWKSet as c } from \"jose\";\nfunction a() {\n  return a = Object.assign || function (e) {\n    for (var t = 1; t < arguments.length; t++) {\n      var r = arguments[t];\n      for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n]);\n    }\n    return e;\n  }, a.apply(this, arguments);\n}\nfunction l(e, t) {\n  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, f(e, t);\n}\nfunction h(e) {\n  return h = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n    return e.__proto__ || Object.getPrototypeOf(e);\n  }, h(e);\n}\nfunction f(e, t) {\n  return f = Object.setPrototypeOf || function (e, t) {\n    return e.__proto__ = t, e;\n  }, f(e, t);\n}\nfunction d() {\n  if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n  if (Reflect.construct.sham) return !1;\n  if (\"function\" == typeof Proxy) return !0;\n  try {\n    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})), !0;\n  } catch (e) {\n    return !1;\n  }\n}\nfunction p(e, t, r) {\n  return p = d() ? Reflect.construct : function (e, t, r) {\n    var n = [null];\n    n.push.apply(n, t);\n    var o = new (Function.bind.apply(e, n))();\n    return r && f(o, r.prototype), o;\n  }, p.apply(null, arguments);\n}\nfunction m(e) {\n  var t = \"function\" == typeof Map ? new Map() : void 0;\n  return m = function (e) {\n    if (null === e || -1 === Function.toString.call(e).indexOf(\"[native code]\")) return e;\n    if (\"function\" != typeof e) throw new TypeError(\"Super expression must either be null or a function\");\n    if (void 0 !== t) {\n      if (t.has(e)) return t.get(e);\n      t.set(e, r);\n    }\n    function r() {\n      return p(e, arguments, h(this).constructor);\n    }\n    return r.prototype = Object.create(e.prototype, {\n      constructor: {\n        value: r,\n        enumerable: !1,\n        writable: !0,\n        configurable: !0\n      }\n    }), f(r, e);\n  }, m(e);\n}\nfunction v(e, t) {\n  if (null == e) return {};\n  var r,\n    n,\n    o = {},\n    i = Object.keys(e);\n  for (n = 0; n < i.length; n++) t.indexOf(r = i[n]) >= 0 || (o[r] = e[r]);\n  return o;\n}\nfunction g(e, t) {\n  (null == t || t > e.length) && (t = e.length);\n  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];\n  return n;\n}\nfunction _(e, t) {\n  var r = \"undefined\" != typeof Symbol && e[Symbol.iterator] || e[\"@@iterator\"];\n  if (r) return (r = r.call(e)).next.bind(r);\n  if (Array.isArray(e) || (r = function (e, t) {\n    if (e) {\n      if (\"string\" == typeof e) return g(e, t);\n      var r = Object.prototype.toString.call(e).slice(8, -1);\n      return \"Object\" === r && e.constructor && (r = e.constructor.name), \"Map\" === r || \"Set\" === r ? Array.from(e) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? g(e, t) : void 0;\n    }\n  }(e)) || t && e && \"number\" == typeof e.length) {\n    r && (e = r);\n    var n = 0;\n    return function () {\n      return n >= e.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: e[n++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction w(e, t) {\n  /*#__PURE__*/return function (r) {\n    function n() {\n      var n;\n      return (n = r.call(this, t) || this).name = e, n;\n    }\n    return l(n, r), n;\n  }( /*#__PURE__*/m(Error));\n}\nvar y = w(\"PopupTimeoutError\", \"The popup has timed out.\"),\n  P = w(\"PopupClosedError\", \"The popup was closed.\"),\n  b = function (e) {\n    return String.fromCharCode.apply(null, Array.from(new Uint8Array(e)));\n  },\n  S = new TextEncoder(),\n  k = function () {\n    return s;\n  },\n  O = function (e) {\n    return k().btoa(e);\n  },\n  R = function (e) {\n    return O(e).replace(/=+$/g, \"\").replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  },\n  A = function () {\n    var e;\n    return null != (e = k().crypto) ? e : k().msCrypto;\n  },\n  j = function (e) {\n    return A().getRandomValues(new Uint8Array(e));\n  },\n  T = function () {\n    var e;\n    return null != (e = A().subtle) ? e : A().webkitSubtle;\n  },\n  z = function (e) {\n    try {\n      var t = T().digest({\n        name: \"SHA-256\"\n      }, e);\n      return k().msCrypto ? Promise.resolve(new Promise(function (e, r) {\n        t.oncomplete = function (t) {\n          return e(t.target.result);\n        }, t.onerror = function (e) {\n          return r(e.error);\n        }, t.onabort = function () {\n          return r(\"The digest operation was aborted\");\n        };\n      })) : Promise.resolve(t);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  },\n  I = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.\",\n  L = function (e) {\n    return k().atob(e);\n  },\n  U = new TextDecoder();\nfunction E(e) {\n  return Array.from(new Set(e));\n}\nvar C = function (e) {\n  return E(e.trim().split(/\\s+/)).sort().join(\" \");\n};\nfunction x(e) {\n  var t = {};\n  return e.forEach(function (r, n) {\n    t[n] = e.getAll(n).length > 1 ? e.getAll(n) : e.get(n);\n  }), t;\n}\nfunction q(e) {\n  var t = new URLSearchParams([].concat(Object.entries(e)).filter(function (e) {\n    return null != e[0] && null != e[1];\n  }));\n  return t.sort(), t.toString();\n}\nvar D = {\n    createCodeChallengeAndVerifier: function (e, t) {\n      void 0 === e && (e = 43), void 0 === t && (t = \"S256\");\n      try {\n        var r = function (e) {\n          return Array.from(j(e)).map(function (e) {\n            return I[e % I.length];\n          }).join(\"\");\n        }(e);\n        switch (t) {\n          case \"plain\":\n            return Promise.resolve({\n              verifier: r,\n              challenge: r\n            });\n          case \"S256\":\n            return Promise.resolve(z(S.encode(r).buffer)).then(function (e) {\n              return {\n                verifier: r,\n                challenge: R(b(e))\n              };\n            });\n          default:\n            throw new Error(\"bad challenge method\");\n        }\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    },\n    getCrypto: A,\n    getCryptoSubtle: T,\n    getRandomBytes: j,\n    sha256: z,\n    verifyIdToken: function (e, t, r, n) {\n      try {\n        return Promise.resolve(u(t, c(new URL(e)), {\n          audience: n\n        })).then(function (e) {\n          var n = e.payload;\n          if (n.__raw = t, r !== n.nonce) throw new Error(\"nonces don't match\");\n          return n;\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }\n  },\n  F = {\n    decodeState: function (e) {\n      var t = e.split(\".\"),\n        r = t[1];\n      if (t.slice(2).length > 0) throw new Error(\"failed to decode state\");\n      return (null == r ? void 0 : r.length) > 0 ? JSON.parse(decodeURIComponent(L(r))) : void 0;\n    },\n    encodeState: function (e) {\n      return R(b(j(32))) + \".\" + (null == e ? \"\" : R(encodeURIComponent(JSON.stringify(e))));\n    },\n    fromBase64: L,\n    textDecoder: U,\n    textEncoder: S,\n    toBase64: O,\n    toUrlEncodedBase64: R,\n    stringFromBuffer: b\n  },\n  N = {\n    __proto__: null,\n    crypto: D,\n    encoding: F,\n    getSortedScope: C,\n    getWindow: k,\n    objectFromEntries: function (e) {\n      for (var t, r = {}, n = _(e); !(t = n()).done;) {\n        var o = t.value;\n        r[o[0]] = o[1];\n      }\n      return r;\n    },\n    objectFromURLSearchParams: x,\n    objectToKey: q,\n    retry: function e(t, r, n, o, i) {\n      return void 0 === r && (r = 4), void 0 === n && (n = 250), void 0 === o && (o = 2), void 0 === i && (i = null), r <= 0 ? Promise.reject(i) : t().catch(function (i) {\n        try {\n          return Promise.resolve(new Promise(function (e) {\n            return setTimeout(e, n);\n          })).then(function () {\n            return e(t, r - 1, n * o, o, i);\n          });\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      });\n    },\n    uniqueElementsFromArray: E\n  },\n  B = /*#__PURE__*/function (e) {\n    function t(t, r, n) {\n      var o;\n      return (o = e.call(this, t + \": \" + r + (n ? \"\\nSee more at \" + n + \".\" : \"\")) || this).code = void 0, o.description = void 0, o.uri = void 0, o.code = t, o.description = r, o.uri = n, o;\n    }\n    return l(t, e), t.fromResponse = function (e) {\n      return new t(e.error, e.error_description, e.error_uri);\n    }, t;\n  }( /*#__PURE__*/m(Error)),\n  M = [\"url\"],\n  W = [\"url\", \"client_id\", \"client_secret\", \"client_auth_method\"],\n  V = /*#__PURE__*/function () {\n    function e(e) {\n      this.options = void 0, this.options = e;\n    }\n    var t = e.prototype;\n    return t.buildAuthorizeUrl = function (e) {\n      return this._buildUrl(e);\n    }, t.buildLogoutUrl = function (e) {\n      return this._buildUrl(e);\n    }, t.parseAuthorizeResponseFromFragment = function (e) {\n      return this._validateResponse(x(new URLSearchParams(new URL(e).hash.substring(1))));\n    }, t.parseAuthorizeResponseFromQuery = function (e) {\n      return this._validateResponse(x(new URL(e).searchParams));\n    }, t.authorizeWithPopup = function (e, t) {\n      void 0 === t && (t = {});\n      try {\n        var r,\n          n = this;\n        if (!window) throw new Error(\"no window in options\");\n        var o = n.buildAuthorizeUrl(e),\n          i = t.popup,\n          s = null != (r = t.timeout) ? r : 36e5;\n        if (i) i.location.href = o;else {\n          var u,\n            c,\n            a = null != (u = t.width) ? u : 600,\n            l = null != (c = t.height) ? c : 800;\n          if (!(i = window.open(o, \"uauth:authorize:popup\", \"left=\" + (window.screenX + (window.innerWidth - a) / 2) + \",top=\" + (window.screenY + (window.innerHeight - l) / 2) + \",width=\" + a + \",height=\" + l + \",resizable,scrollbars=yes,status=1\"))) throw new Error(\"popup failed to be constructed\");\n        }\n        var h = !1;\n        return Promise.resolve(new Promise(function (t, r) {\n          var o = setTimeout(function () {\n              h || (clearInterval(u), i.close(), r(new y()));\n            }, s),\n            u = setInterval(function () {\n              var s, c, a, l;\n              !h && null != (s = i) && s.closed && (clearInterval(u), clearTimeout(o), r(new P()));\n              try {\n                c = i.location.href, a = new URL(c), l = new URL(e.redirect_uri);\n              } catch (e) {\n                return;\n              }\n              if (a.hash = \"\", a.href === l.href) {\n                h = !0, clearInterval(u), clearTimeout(o), i.close();\n                try {\n                  t(n.parseAuthorizeResponseFromFragment(c));\n                } catch (e) {\n                  r(e);\n                }\n              }\n            }, 10);\n        }));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.authorizeWithDevice = function (e) {\n      return Promise.resolve({});\n    }, t.getToken = function (e) {\n      try {\n        var t = this._buildRequest(e, {\n          method: \"POST\"\n        });\n        return Promise.resolve(this._fetchJSON(t[0], t[1]));\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.introspect = function (e) {\n      var t = this._buildRequest(e, {\n        method: \"POST\"\n      });\n      return this._fetchJSON(t[0], t[1]);\n    }, t.revoke = function (e) {\n      try {\n        var t = this._buildRequest(e, {\n          method: \"POST\"\n        });\n        return Promise.resolve(this._fetchJSON(t[0], t[1])).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.userinfo = function (e) {\n      var t = this._buildRequest(e, {\n        method: \"GET\",\n        headers: {\n          Authorization: \"Basic \" + e.access_token\n        }\n      });\n      return this._fetchJSON(t[0], t[1]);\n    }, t.jwks = function (e) {\n      var t = this._buildRequest(e, {\n        method: \"GET\"\n      });\n      return this._fetchJSON(t[0], t[1]);\n    }, t.getTokenWithAuthorizationCode = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithRefreshToken = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithDeviceCode = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithPassword = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithSAML = function (e) {\n      return this.getToken(e);\n    }, t.getTokenWithClientCredentials = function (e) {\n      return this.getToken(e);\n    }, t._buildUrl = function (e) {\n      for (var t = e.url, r = v(e, M), n = new URL(t), o = new URLSearchParams(), i = 0, s = Object.entries(r); i < s.length; i++) {\n        var u = s[i],\n          c = u[0],\n          a = u[1];\n        null != c && null != a && o.append(c, a);\n      }\n      return n.search = o.toString(), n.toString();\n    }, t._buildRequest = function (e, t) {\n      var r,\n        n = e.url,\n        o = e.client_id,\n        i = e.client_secret,\n        s = e.client_auth_method,\n        u = v(e, W),\n        c = t.headers,\n        l = t.method,\n        h = new Headers(null != (r = this.options.headers) ? r : []);\n      new Headers(null != c ? c : []).forEach(function (e, t) {\n        h.set(t, e);\n      }), \"POST\" === t.method && h.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n      var f = a({\n        client_id: o\n      }, u);\n      switch (s) {\n        case \"client_secret_basic\":\n          if (null == i) throw new Error(\"Client secret not present!\");\n          h.set(\"Authorization\", \"Basic \" + O(o + \":\" + i));\n          break;\n        case \"client_secret_post\":\n          if (null == i) throw new Error(\"Client secret not present!\");\n          f.client_secret = i;\n          break;\n        case \"none\":\n        case void 0:\n        case null:\n          break;\n        default:\n          throw new Error(\"Bad client_auth_method\");\n      }\n      return [n, {\n        method: l,\n        headers: h,\n        body: \"POST\" === l ? new URLSearchParams(Object.entries(f)) : void 0\n      }];\n    }, t._validateResponse = function (t) {\n      if (t.error) throw e.Error.fromResponse(t);\n      return t;\n    }, t._fetchJSON = function (e, t) {\n      try {\n        var r,\n          n = this;\n        if (t.headers) {\n          var o = new Headers(t.headers);\n          o.set(\"Accept\", \"application/json\"), t.headers = o;\n        } else t.headers = {\n          Accept: \"application/json\"\n        };\n        return Promise.resolve(null == (r = window) ? void 0 : r.fetch(e, t)).then(function (e) {\n          return Promise.resolve(e.json()).then(function (t) {\n            if (n._validateResponse(t), !e.ok) throw new Error(e.status + \" \" + e.statusText + \": \" + JSON.stringify(t));\n            return t;\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, e;\n  }();\nV.Error = B;\nvar J = /*#__PURE__*/function () {\n    function e(e) {\n      this.client = void 0, this.client = e;\n    }\n    var t = e.prototype;\n    return t.get = function (e, t) {\n      var r = void 0 === t ? {} : t,\n        n = r.mustExist,\n        o = void 0 !== n && n,\n        i = r.deleteAfter,\n        s = void 0 !== i && i;\n      try {\n        var u = this;\n        return Promise.resolve(u.client.getStore().get(e)).then(function (t) {\n          var r;\n          function n(t) {\n            if (r) return t;\n            var n = function () {\n              if (s) return Promise.resolve(u.client.getStore().delete(e)).then(function () {});\n            }();\n            return n && n.then ? n.then(function () {\n              return i;\n            }) : i;\n          }\n          if (null != t) {\n            var i = t.value,\n              c = t.expiresAt,\n              a = function () {\n                if (0 !== c && c < Date.now()) return Promise.resolve(u.client.getStore().delete(e)).then(function () {\n                  if (o) throw new Error(e + \" does not exist in store\");\n                  r = 1;\n                });\n              }();\n            return a && a.then ? a.then(n) : n(a);\n          }\n          if (o) throw new Error(e + \" does not exist in store\");\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.set = function (e, t, r) {\n      void 0 === r && (r = 0);\n      try {\n        return Promise.resolve(this.client.getStore().set(e, {\n          expiresAt: 0 === r ? 0 : Date.now() + r,\n          value: t\n        })).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.setAuthorizeRequest = function (e) {\n      try {\n        return Promise.resolve(this.set(\"request\", e, 3e5)).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getAuthorizeRequest = function () {\n      return this.get(\"request\", {\n        mustExist: !0,\n        deleteAfter: !0\n      });\n    }, t.setLogoutRequest = function (e) {\n      try {\n        return Promise.resolve(this.set(\"logout-request\", e, 3e5)).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getLogoutRequest = function () {\n      return this.get(\"logout-request\", {\n        mustExist: !0,\n        deleteAfter: !0\n      });\n    }, t.setVerifier = function (e, t) {\n      try {\n        return Promise.resolve(this.set(\"verifier:\" + e, t, 3e5)).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getVerifier = function (e) {\n      return this.get(\"verifier:\" + e, {\n        mustExist: !0,\n        deleteAfter: !0\n      });\n    }, t.setOpenIdConfiguration = function (e, t, r) {\n      try {\n        return Promise.resolve(this.set(\"openidConfiguration:\" + e, t, r)).then(function () {});\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getOpenIdConfiguration = function (e) {\n      return this.get(\"openidConfiguration:\" + e);\n    }, t.setAuthorization = function (e) {\n      try {\n        var t = this,\n          r = {\n            clientID: e.idToken.aud,\n            resource: e.resource,\n            scope: e.scope,\n            username: e.idToken.sub\n          },\n          n = e.expiresAt - Date.now();\n        return Promise.resolve(t.set(\"username\", r.username, n)).then(function () {\n          var o = t.set;\n          return Promise.resolve(t._getAuthorizationKey(r)).then(function (r) {\n            return Promise.resolve(o.call(t, r, e, n)).then(function () {});\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.deleteAuthorization = function (e) {\n      try {\n        var t = this;\n        return Promise.resolve(t.get(\"username\")).then(function (r) {\n          return Promise.resolve(t._getUsername(e.username, r)).then(function (n) {\n            function o() {\n              var r = t.client.getStore(),\n                n = r.delete;\n              return Promise.resolve(t._getAuthorizationKey(e)).then(function (e) {\n                return n.call(r, e);\n              });\n            }\n            e.username = n;\n            var i = function () {\n              if (e.username === r) return Promise.resolve(t.client.getStore().delete(\"username\")).then(function () {});\n            }();\n            return i && i.then ? i.then(o) : o();\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t.getAuthorization = function (e) {\n      try {\n        var t = this,\n          r = t.get;\n        return Promise.resolve(t._getAuthorizationKey(e)).then(function (e) {\n          return r.call(t, e, {\n            mustExist: !0\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t._getAuthorizationKey = function (e) {\n      try {\n        var t = this,\n          r = q,\n          n = t._getUsername,\n          o = e.username;\n        return Promise.resolve(t.get(\"username\")).then(function (i) {\n          return Promise.resolve(n.call(t, o, i)).then(function (n) {\n            var o, i, s;\n            return \"authorization?\" + r.call(N, {\n              username: n,\n              clientID: null != (o = e.clientID) ? o : t.client.fallbackLoginOptions.clientID,\n              scope: C(null != (i = e.scope) ? i : t.client.fallbackLoginOptions.scope),\n              resource: null != (s = e.resource) ? s : t.client.fallbackLoginOptions.resource\n            });\n          });\n        });\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, t._getUsername = function (e, t) {\n      try {\n        if (null == e && null == t) throw new Error(\"no username given\");\n        return Promise.resolve(null != e ? e : t);\n      } catch (e) {\n        return Promise.reject(e);\n      }\n    }, e;\n  }(),\n  H = /*#__PURE__*/function () {\n    function e(e) {\n      this.storage = void 0, this.storage = e;\n    }\n    var t = e.prototype;\n    return t.get = function (e) {\n      var t = this.storage.getItem(e);\n      return null != t ? JSON.parse(t) : null;\n    }, t.delete = function (e) {\n      return this.storage.removeItem(e), !0;\n    }, t.set = function (e, t) {\n      return this.storage.setItem(e, JSON.stringify(t)), this;\n    }, e;\n  }(),\n  K = [\"clientID\", \"username\", \"scope\", \"resource\"];\nif (\"undefined\" != typeof window) {\n  var Q = window;\n  Q.UAUTH_VERSION = Q.UAUTH_VERSION || {}, Q.UAUTH_VERSION.JS = \"2.4.0\";\n}\nvar G = /*#__PURE__*/function () {\n  var s = u.prototype;\n  function u(s) {\n    var u, c, l, h, f, d, p, m, v, g;\n    this.util = N, this._clientStore = new J(this), this.api = void 0, this.fallbackIssuer = void 0, this.fallbackLoginOptions = void 0, this.fallbackLogoutOptions = void 0, this.cacheOptions = void 0, this.issuerResolver = void 0, this.resolution = void 0, this.store = void 0, this.storeOptions = void 0, this.fallbackIssuer = null != (u = s.fallbackIssuer) ? u : \"https://auth.unstoppabledomains.com\", this.resolution = null != (c = s.resolution) ? c : new n(), this.storeOptions = {\n      store: s.store,\n      storeType: null != (l = s.storeType) ? l : \"localstore\"\n    }, this.cacheOptions = a({\n      issuer: !1,\n      userinfo: !0\n    }, null != (h = s.cacheOptions) ? h : {}), this.api = new V({\n      headers: {}\n    }), this.fallbackLoginOptions = {\n      clientID: s.clientID,\n      clientSecret: s.clientSecret,\n      clientAuthMethod: null != (f = s.clientAuthMethod) ? f : s.clientSecret ? \"client_secret_post\" : \"none\",\n      maxAge: null != (d = s.maxAge) ? d : 3e5,\n      prompt: null != (p = s.prompt) ? p : \"login\",\n      resource: s.resource,\n      redirectUri: s.redirectUri,\n      responseMode: null != (m = s.responseMode) ? m : \"fragment\",\n      scope: null != (v = s.scope) ? v : \"openid wallet\"\n    }, this.fallbackLogoutOptions = {\n      rpInitiatedLogout: null != (g = s.rpInitiatedLogout) ? g : \"string\" == typeof s.postLogoutRedirectUri,\n      postLogoutRedirectUri: s.postLogoutRedirectUri\n    };\n    var _ = this;\n    this.issuerResolver = new e({\n      webfingerResolver: new t({\n        ipfsResolver: new r(function () {\n          return (s.createIpfsUrl || r.defaultCreateUrl).apply(void 0, [].slice.call(arguments));\n        }),\n        domainResolver: {\n          records: function (e, t) {\n            try {\n              return Promise.resolve(function (r, n) {\n                try {\n                  var o = Promise.resolve(_.resolution.records(e, t));\n                } catch (e) {\n                  return n(e);\n                }\n                return o && o.then ? o.then(void 0, n) : o;\n              }(0, function (e) {\n                if (e instanceof o && e.code === i.UnspecifiedResolver) return {};\n                throw e;\n              }));\n            } catch (e) {\n              return Promise.reject(e);\n            }\n          }\n        }\n      })\n    });\n  }\n  return s.getStore = function () {\n    if (this.store) return this.store;\n    if (this.storeOptions.store) this.store = this.storeOptions.store;else switch (this.storeOptions.storeType) {\n      case \"localstore\":\n        this.store = new H(window.localStorage);\n        break;\n      case \"sessionstore\":\n        this.store = new H(window.sessionStorage);\n        break;\n      case \"memory\":\n        this.store = new Map();\n        break;\n      default:\n        throw new Error(\"Bad storeType provided\");\n    }\n    return this.store;\n  }, s.buildAuthorizeRequest = function (e) {\n    try {\n      var t = this,\n        r = a({}, t.fallbackLoginOptions, e),\n        n = e.username;\n      return Promise.resolve(t.getOpenIdConfiguration(n)).then(function (e) {\n        return Promise.resolve(D.createCodeChallengeAndVerifier(43, \"S256\")).then(function (o) {\n          var i,\n            s = o.verifier,\n            u = o.challenge,\n            c = F.toBase64(F.stringFromBuffer(D.getRandomBytes(32))),\n            a = F.encodeState(r.state),\n            l = {\n              url: e.authorization_endpoint,\n              code_challenge: u,\n              nonce: c,\n              state: a,\n              flow_id: null != (i = r.flowId) ? i : \"login\",\n              login_hint: n,\n              client_id: r.clientID,\n              client_secret: r.clientSecret,\n              client_auth_method: r.clientAuthMethod,\n              max_age: r.maxAge,\n              prompt: r.prompt,\n              resource: r.resource,\n              redirect_uri: r.redirectUri,\n              response_mode: r.responseMode,\n              scope: r.scope,\n              code_challenge_method: \"S256\",\n              response_type: \"code\",\n              package_name: (null == r ? void 0 : r.packageName) || \"@uauth/js\",\n              package_version: (null == r ? void 0 : r.packageVersion) || \"2.4.0\"\n            };\n          return Promise.resolve(t._clientStore.setAuthorizeRequest(l)).then(function () {\n            return Promise.resolve(t._clientStore.setVerifier(u, s)).then(function () {\n              return l;\n            });\n          });\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.loginWithPopup = function (e, t) {\n    void 0 === e && (e = {});\n    try {\n      var r = this;\n      return e.responseMode = \"fragment\", Promise.resolve(r.buildAuthorizeRequest(e)).then(function (e) {\n        return Promise.resolve(r.api.authorizeWithPopup(e, t)).then(function (t) {\n          return Promise.resolve(r.verifyAuthorizeResponse(e, t));\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.login = function (e) {\n    void 0 === e && (e = {});\n    try {\n      var t = this;\n      return Promise.resolve(t.buildAuthorizeRequest(e)).then(function (r) {\n        function n() {\n          window.location.href = o;\n        }\n        var o = t.api.buildAuthorizeUrl(r),\n          i = function () {\n            if (\"function\" == typeof e.beforeRedirect) return Promise.resolve(e.beforeRedirect(o)).then(function () {});\n          }();\n        return i && i.then ? i.then(n) : n();\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.loginCallback = function (e) {\n    try {\n      var t,\n        r = this,\n        n = null != (t = null == e ? void 0 : e.url) ? t : window.location.href;\n      return Promise.resolve(r._clientStore.getAuthorizeRequest()).then(function (e) {\n        var t;\n        if (\"fragment\" === e.response_mode) t = r.api.parseAuthorizeResponseFromFragment(n);else {\n          if (\"query\" !== e.response_mode) throw new Error(\"Unsupported response_mode\");\n          t = r.api.parseAuthorizeResponseFromQuery(n);\n        }\n        return Promise.resolve(r.verifyAuthorizeResponse(e, t)).then(function (t) {\n          return {\n            authorization: t,\n            state: F.decodeState(e.state)\n          };\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.verifyAuthorizeResponse = function (e, t) {\n    try {\n      var r = this;\n      if (e.state !== t.state) throw new Error(\"states don't match\");\n      return Promise.resolve(r.getOpenIdConfiguration(e.login_hint)).then(function (n) {\n        var o = t.code,\n          i = e.client_auth_method,\n          s = e.client_secret,\n          u = e.client_id,\n          c = n.token_endpoint;\n        return Promise.resolve(r._clientStore.getVerifier(e.code_challenge)).then(function (t) {\n          return Promise.resolve(r.api.getTokenWithAuthorizationCode({\n            url: c,\n            client_id: u,\n            client_secret: s,\n            client_auth_method: i,\n            grant_type: \"authorization_code\",\n            code: o,\n            code_verifier: t,\n            redirect_uri: e.redirect_uri\n          })).then(function (t) {\n            return Promise.resolve(D.verifyIdToken(n.jwks_uri, t.id_token, e.nonce, e.client_id)).then(function (n) {\n              var o = {\n                accessToken: t.access_token,\n                expiresAt: Date.now() + 1e3 * t.expires_in,\n                idToken: n,\n                scope: C(e.scope),\n                resource: e.resource\n              };\n              return Promise.resolve(r._clientStore.setAuthorization(o)).then(function () {\n                return o;\n              });\n            });\n          });\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.getVerifiedAccounts = function (e, t) {\n    void 0 === t && (t = []);\n    var r = [];\n    return e.idToken.verified_addresses ? (e.idToken.verified_addresses.forEach(function (e) {\n      t.length > 0 && !t.includes(e.symbol) || r.push({\n        address: e.address,\n        message: e.proof.message,\n        signature: e.proof.signature,\n        symbol: e.symbol\n      });\n    }), r) : r;\n  }, s.getAuthorizationAccount = function (e, t, r) {\n    var n;\n    void 0 === t && (t = \"sig\"), void 0 === r && (r = \"v1\");\n    var o = null == (n = e.idToken.amr) ? void 0 : n.filter(function (e) {\n      return e.startsWith(r + \".\" + t);\n    });\n    if (o && 0 != o.length) {\n      var i = o[0].split(\".\")[3],\n        s = this.getVerifiedAccounts(e);\n      if (s) for (var u, c = _(s); !(u = c()).done;) {\n        var a = u.value;\n        if (a.address === i) return a;\n      }\n    }\n  }, s.getOpenIdConfiguration = function (e) {\n    try {\n      var t,\n        r = function (r) {\n          return t ? r : Promise.resolve(e ? n.issuerResolver.resolve(e, n.fallbackIssuer) : fetch(n.fallbackIssuer + \"/.well-known/openid-configuration\").then(function (e) {\n            return e.ok ? e.json() : Promise.reject(new Error(\"bad openid-configuration response\"));\n          })).then(function (t) {\n            return Promise.resolve(n._clientStore.setOpenIdConfiguration(null != e ? e : \"\", t, \"number\" == typeof n.cacheOptions.issuer ? n.cacheOptions.issuer : 36e5)).then(function () {\n              return t;\n            });\n          });\n        },\n        n = this,\n        o = function () {\n          if (n.cacheOptions.issuer) return Promise.resolve(n._clientStore.getOpenIdConfiguration(null != e ? e : \"\")).then(function (e) {\n            if (e) return t = 1, e;\n          });\n        }();\n      return Promise.resolve(o && o.then ? o.then(r) : r(o));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.authorization = function (e) {\n    void 0 === e && (e = {});\n    try {\n      return Promise.resolve(this._clientStore.getAuthorization(e));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.user = function (e) {\n    void 0 === e && (e = {});\n    try {\n      var t,\n        r = this,\n        n = null != (t = e.claims) ? t : [\"name\", \"given_name\", \"family_name\", \"middle_name\", \"nickname\", \"preferred_username\", \"profile\", \"picture\", \"website\", \"email\", \"email_verified\", \"gender\", \"birthdate\", \"zoneinfo\", \"locale\", \"phone_number\", \"phone_number_verified\", \"address\", \"updated_at\", \"wallet_address\", \"wallet_type_hint\", \"eip4361_message\", \"eip4361_signature\", \"humanity_check_id\"];\n      return Promise.resolve(r.authorization(e)).then(function (e) {\n        var t = {\n          sub: e.idToken.sub\n        };\n        if (r.cacheOptions.userinfo) {\n          for (var o, i = _(n); !(o = i()).done;) {\n            var s = o.value;\n            e.idToken[s] && (t[s] = e.idToken[s]);\n          }\n          return t;\n        }\n        return Promise.resolve(r.getOpenIdConfiguration(e.idToken.sub)).then(function (o) {\n          return Promise.resolve(r.api.userinfo({\n            client_id: r.fallbackLoginOptions.clientID,\n            client_secret: r.fallbackLoginOptions.clientSecret,\n            client_auth_method: r.fallbackLoginOptions.clientAuthMethod,\n            access_token: e.accessToken,\n            url: o.userinfo_endpoint\n          })).then(function (e) {\n            for (var r, o = _(n); !(r = o()).done;) {\n              var i = r.value;\n              e[i] && (t[i] = e[i]);\n            }\n            return t;\n          });\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.buildLogoutRequest = function (e) {\n    try {\n      var t = this;\n      return Promise.resolve(t.authorization(e)).then(function (r) {\n        return Promise.resolve(t.getOpenIdConfiguration(r.idToken.sub)).then(function (n) {\n          var o;\n          if (null == n.end_session_endpoint) throw new Error(\"end_session_endpoint must exist\");\n          var i = null != (o = e.postLogoutRedirectUri) ? o : t.fallbackLogoutOptions.postLogoutRedirectUri;\n          if (null == i) throw new Error(\"postLogoutRedirectUri must be supplied\");\n          var s = {\n            client_id: t.fallbackLoginOptions.clientID,\n            client_secret: t.fallbackLoginOptions.clientSecret,\n            client_auth_method: t.fallbackLoginOptions.clientAuthMethod,\n            url: n.end_session_endpoint,\n            id_token_hint: r.idToken.__raw,\n            post_logout_redirect_uri: i,\n            state: F.encodeState(e.state)\n          };\n          return Promise.resolve(t._clientStore.setLogoutRequest(s)).then(function () {\n            return s;\n          });\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.logout = function (e) {\n    var t = void 0 === e ? {} : e,\n      r = t.clientID,\n      n = t.username,\n      o = t.scope,\n      i = t.resource,\n      s = v(t, K);\n    try {\n      var u,\n        c = function (e) {\n          return u ? e : Promise.resolve(l.buildLogoutRequest(h)).then(function (e) {\n            function t() {\n              return Promise.resolve(l._clientStore.deleteAuthorization(f)).then(function () {\n                window.location.href = r;\n              });\n            }\n            var r = l.api.buildLogoutUrl(e),\n              n = function () {\n                if (\"function\" == typeof h.beforeRedirect) return Promise.resolve(h.beforeRedirect(r)).then(function () {});\n              }();\n            return n && n.then ? n.then(t) : t();\n          });\n        },\n        l = this,\n        h = a({}, l.fallbackLogoutOptions, s),\n        f = {\n          clientID: r,\n          username: n,\n          scope: o,\n          resource: i\n        },\n        d = function () {\n          if (!h.rpInitiatedLogout) return Promise.resolve(l._clientStore.deleteAuthorization(f)).then(function () {\n            u = 1;\n          });\n        }();\n      return Promise.resolve(d && d.then ? d.then(c) : c(d));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.logoutCallback = function (e) {\n    void 0 === e && (e = {});\n    try {\n      var t,\n        r,\n        n = this,\n        o = null != (t = null == (r = e) ? void 0 : r.url) ? t : window.location.href;\n      return Promise.resolve(n._clientStore.getLogoutRequest()).then(function (e) {\n        var t = n.api.parseAuthorizeResponseFromQuery(o);\n        return Promise.resolve(n.verifyLogoutResponse(e, t)).then(function () {\n          return F.decodeState(e.state);\n        });\n      });\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, s.verifyLogoutResponse = function (e, t) {\n    try {\n      if (e.state !== t.state) throw new Error(\"states don't match\");\n      return Promise.resolve();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }, u;\n}();\nexport { G as default };","map":{"version":3,"mappings":"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","names":["createError","name","message","_class2","_this","this","_inheritsLoose","Error","PopupTimeoutError","PopupClosedError","stringFromBuffer","buf","String","fromCharCode","apply","Array","from","Uint8Array","textEncoder","TextEncoder","getWindow","window","toBase64","str","btoa","toUrlEncodedBase64","replace","getCrypto","crypto","_getWindow$crypto","msCrypto","getRandomBytes","length","getRandomValues","getCryptoSubtle","subtle","_getCrypto$subtle","webkitSubtle","sha256","digestOp","digest","Promise","res","rej","oncomplete","e","target","result","onerror","error","onabort","pkceMask","fromBase64","atob","textDecoder","TextDecoder","uniqueElementsFromArray","arr","Set","getSortedScope","scope","trim","split","sort","join","objectFromURLSearchParams","params","obj","forEach","_","key","getAll","get","object","URLSearchParams","Object","entries","filter","_ref","toString","createCodeChallengeAndVerifier","method","verifier","map","v","createCodeVerifier","challenge","encode","buffer","then","verifyIdToken","jwks_uri","id_token","nonce","client_id","jwtVerify","createRemoteJWKSet","URL","audience","payload","idToken","__raw","encoding","decodeState","state","_state$split","JSON","parse","decodeURIComponent","undefined","encodeState","encodeURIComponent","stringify","objectFromEntries","_step","_step$value","retry","fn","retries","timeout","factor","err","reject","catch","r","setTimeout","ApiError","code","description","uri","fromResponse","response","error_description","error_uri","_excluded","_excluded2","Api","options","buildAuthorizeUrl","request","_buildUrl","buildLogoutUrl","parseAuthorizeResponseFromFragment","url","_validateResponse","hash","substring","parseAuthorizeResponseFromQuery","searchParams","authorizeWithPopup","config","_this2","popup","_config$timeout","location","href","_config$height","width","_config$width","height","open","screenX","innerWidth","screenY","innerHeight","recievedMessage","resolve","timeoutId","clearInterval","intervalId","close","setInterval","redirectUrl","_popup","closed","clearTimeout","redirect_uri","authorizeWithDevice","getToken","_buildRequest","_fetchJSON","_this4$_buildRequest","introspect","_this$_buildRequest","init","revoke","_this6$_buildRequest","userinfo","headers","Authorization","access_token","_this$_buildRequest2","jwks","_this$_buildRequest3","getTokenWithAuthorizationCode","getTokenWithRefreshToken","getTokenWithDeviceCode","getTokenWithPassword","getTokenWithSAML","getTokenWithClientCredentials","_objectWithoutPropertiesLoose","urlObject","_i","k","_Object$entries$_i","append","search","client_secret","client_auth_method","rest","headersInit","Headers","_this$options$headers","value","set","body","input","_this8","Accept","_window","fetch","json","ok","status","statusText","ClientStore","client","n","mustExist","deleteAfter","getStore","entry","expiresAt","Date","now","_exit","_temp2","setAuthorizeRequest","getAuthorizeRequest","setLogoutRequest","getLogoutRequest","setVerifier","getVerifier","setOpenIdConfiguration","username","openidConfiguration","getOpenIdConfiguration","setAuthorization","authorization","authorizationOptions","clientID","aud","resource","sub","expiresIn","_getAuthorizationKey","deleteAuthorization","fallbackUsername","_getUsername","_delete","_this15$client$getSto","_this15$_getAuthoriza","_this15$_getUsername","_this16","_temp6","getAuthorization","_get2","_this18","util","_getUsername3","_this20","_this19$_getUsername","_options$clientID","fallbackLoginOptions","_options$resource","StorageStore","storage","getItem","_proto","removeItem","setItem","_w","UAUTH_VERSION","JS","Client","_clientStore","api","fallbackIssuer","fallbackLogoutOptions","cacheOptions","issuerResolver","resolution","store","storeOptions","_options$fallbackIssu","_options$resolution","Resolution","storeType","_options$storeType","issuer","_options$cacheOptions","clientSecret","clientAuthMethod","_options$clientAuthMe","maxAge","_options$maxAge","prompt","_options$prompt","redirectUri","responseMode","_options$responseMode","_options$scope","rpInitiatedLogout","_options$rpInitiatedL","postLogoutRedirectUri","self","DefaultIssuerResolver","webfingerResolver","DefaultWebFingerResolver","ipfsResolver","DefaultIPFSResolver","createIpfsUrl","defaultCreateUrl","arguments","domainResolver","records","domain","keys","_catch","ResolutionError","ResolutionErrorCode","UnspecifiedResolver","localStorage","sessionStorage","Map","buildAuthorizeRequest","loginOptions","_extends","loginHint","authorization_endpoint","code_challenge","flow_id","flowId","_loginOptions$flowId","login_hint","max_age","response_mode","code_challenge_method","response_type","package_name","packageName","package_version","packageVersion","loginWithPopup","_this4","verifyAuthorizeResponse","login","_this6","_temp","beforeRedirect","loginCallback","_options$url","_this7$verifyAuthoriz","_this10","_request$client_auth_","token_endpoint","_openidConfiguration$","_request$client_id","_request$client_secre","grant_type","_response$code","code_verifier","tokenResponse","accessToken","expires_in","getVerifiedAccounts","symbols","verifiedAddresses","verified_addresses","record","includes","symbol","push","address","proof","signature","getAuthorizationAccount","type","version","_authorization$idToke","sigProofKeys","amr","startsWith","sigAddress","verifiedAccounts","account","_temp5","_this12","resp","user","claims","_options$claims","claim","_step2","userinfo_endpoint","_step3","buildLogoutRequest","end_session_endpoint","_options$postLogoutRe","id_token_hint","post_logout_redirect_uri","logout","_exit4","_temp12","logoutOptions","_temp7","_temp8","_temp13","logoutCallback","_options","_this22","_options$url2","verifyLogoutResponse"],"sources":["../src/errors/createError.ts","../src/errors/errors.ts","../src/util/encoding/stringFromBuffer.ts","../src/util/encoding/textEncoder.ts","../src/util/getWindow.ts","../src/util/encoding/toBase64.ts","../src/util/encoding/toUrlEncodedBase64.ts","../src/util/crypto/getCrypto.ts","../src/util/crypto/getRandomBytes.ts","../src/util/crypto/getCryptoSubtle.ts","../src/util/crypto/sha256.ts","../src/util/crypto/createCodeChallengeAndVerifier.ts","../src/util/encoding/fromBase64.ts","../src/util/encoding/textDecoder.ts","../src/util/uniqueElementsFromArray.ts","../src/util/getSortedScope.ts","../src/util/objectFromURLSearchParams.ts","../src/util/objectToKey.ts","../src/util/index.ts","../src/util/crypto/verifyIdToken.ts","../src/util/encoding/decodeState.ts","../src/util/encoding/encodeState.ts","../src/util/objectFromEntries.ts","../src/util/retry.ts","../src/api/ApiError.ts","../src/api/Api.ts","../src/ClientStore.ts","../src/store/StorageStore.ts","../src/Client.ts","../src/version.ts"],"sourcesContent":["export default function createError(name: string, message: string) {\n  return class extends Error {\n    name = name\n    constructor() {\n      super(message)\n    }\n  }\n}\n","import createError from './createError'\n\nexport const PopupTimeoutError = createError(\n  'PopupTimeoutError',\n  'The popup has timed out.',\n)\n\nexport const PopupClosedError = createError(\n  'PopupClosedError',\n  'The popup was closed.',\n)\n","const stringFromBuffer = (buf: ArrayBuffer): string =>\n  String.fromCharCode.apply(null, Array.from(new Uint8Array(buf)))\n\nexport default stringFromBuffer\n","const textEncoder = new TextEncoder()\n\nexport default textEncoder\n","import window from 'global'\n\nconst getWindow: () => Window & typeof globalThis = () => window\n\nexport default getWindow\n","import getWindow from '../getWindow'\n\nconst toBase64 = (str: string) => getWindow().btoa(str)\n\nexport default toBase64\n","import toBase64 from './toBase64'\n\nconst toUrlEncodedBase64 = (str: string) => {\n  return toBase64(str)\n    .replace(/=+$/g, '')\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n}\n\nexport default toUrlEncodedBase64\n","import getWindow from '../getWindow'\n\n//ie 11.x uses msCrypto\nconst getCrypto = () =>\n  (getWindow().crypto ?? (getWindow() as any).msCrypto) as Crypto\n\nexport default getCrypto\n","import getCrypto from './getCrypto'\n\nconst getRandomBytes = (length: number): Uint8Array =>\n  getCrypto().getRandomValues(new Uint8Array(length))\n\nexport default getRandomBytes\n","import getCrypto from './getCrypto'\n\n//safari 10.x uses webkitSubtle\nconst getCryptoSubtle = () =>\n  getCrypto().subtle ?? (getCrypto() as any).webkitSubtle\n\nexport default getCryptoSubtle\n","import getWindow from '../getWindow'\nimport getCryptoSubtle from './getCryptoSubtle'\n\nconst sha256 = async (buf: ArrayBuffer): Promise<ArrayBuffer> => {\n  const digestOp: any = getCryptoSubtle().digest({name: 'SHA-256'}, buf)\n\n  // This is for legacy IE Hashing\n  if ((getWindow() as any).msCrypto) {\n    return new Promise((res, rej) => {\n      digestOp.oncomplete = (e: any) => res(e.target.result)\n      digestOp.onerror = (e: ErrorEvent) => rej(e.error)\n      digestOp.onabort = () => rej('The digest operation was aborted')\n    })\n  }\n\n  return await digestOp\n}\n\nexport default sha256\n","import type {CodeChallengeMethod} from '../../types'\nimport stringFromBuffer from '../encoding/stringFromBuffer'\nimport textEncoder from '../encoding/textEncoder'\nimport toUrlEncodedBase64 from '../encoding/toUrlEncodedBase64'\nimport getRandomBytes from './getRandomBytes'\nimport sha256 from './sha256'\n\nconst pkceMask =\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_~.'\n\nconst createCodeVerifier = (length: number) => {\n  return Array.from(getRandomBytes(length))\n    .map(v => pkceMask[v % pkceMask.length])\n    .join('')\n}\n\nconst createCodeChallengeAndVerifier = async (\n  length = 43,\n  method: CodeChallengeMethod = 'S256',\n): Promise<{verifier: string; challenge: string}> => {\n  const verifier = createCodeVerifier(length)\n\n  switch (method) {\n    case 'plain':\n      return {verifier, challenge: verifier}\n    case 'S256':\n      return {\n        verifier,\n        challenge: toUrlEncodedBase64(\n          stringFromBuffer(await sha256(textEncoder.encode(verifier).buffer)),\n        ),\n      }\n    default:\n      throw new Error('bad challenge method')\n  }\n}\n\nexport default createCodeChallengeAndVerifier\n","import getWindow from '../getWindow'\n\nconst fromBase64 = (str: string): string => getWindow().atob(str)\n\nexport default fromBase64\n","const textDecoder = new TextDecoder()\n\nexport default textDecoder\n","export default function uniqueElementsFromArray<T>(arr: T[]): T[] {\n  return Array.from(new Set(arr))\n}\n","import uniqueElementsFromArray from './uniqueElementsFromArray'\n\nconst getSortedScope = (scope: string) =>\n  uniqueElementsFromArray(scope.trim().split(/\\s+/)).sort().join(' ')\n\nexport default getSortedScope\n","export default function objectFromURLSearchParams(\n  params: URLSearchParams,\n): Record<string, string | string[]> {\n  const obj = {}\n\n  params.forEach((_, key) => {\n    if (params.getAll(key).length > 1) {\n      obj[key] = params.getAll(key)\n    } else {\n      obj[key] = params.get(key)\n    }\n  })\n\n  return obj\n}\n","export default function objectToKey(object: Record<PropertyKey, any>): string {\n  const params = new URLSearchParams(\n    [...Object.entries(object)].filter(([k, v]) => k != null && v != null),\n  )\n  params.sort()\n  return params.toString()\n}\n","import createCodeChallengeAndVerifier from './crypto/createCodeChallengeAndVerifier'\nimport getCrypto from './crypto/getCrypto'\nimport getCryptoSubtle from './crypto/getCryptoSubtle'\nimport getRandomBytes from './crypto/getRandomBytes'\nimport sha256 from './crypto/sha256'\nimport verifyIdToken from './crypto/verifyIdToken'\nimport decodeState from './encoding/decodeState'\nimport encodeState from './encoding/encodeState'\nimport fromBase64 from './encoding/fromBase64'\nimport stringFromBuffer from './encoding/stringFromBuffer'\nimport textDecoder from './encoding/textDecoder'\nimport textEncoder from './encoding/textEncoder'\nimport toBase64 from './encoding/toBase64'\nimport toUrlEncodedBase64 from './encoding/toUrlEncodedBase64'\n\nconst crypto = {\n  createCodeChallengeAndVerifier,\n  getCrypto,\n  getCryptoSubtle,\n  getRandomBytes,\n  sha256,\n  verifyIdToken,\n}\n\nconst encoding = {\n  decodeState,\n  encodeState,\n  fromBase64,\n  textDecoder,\n  textEncoder,\n  toBase64,\n  toUrlEncodedBase64,\n  stringFromBuffer,\n}\n\nexport {default as getSortedScope} from './getSortedScope'\nexport {default as getWindow} from './getWindow'\nexport {default as objectFromEntries} from './objectFromEntries'\nexport {default as objectFromURLSearchParams} from './objectFromURLSearchParams'\nexport {default as objectToKey} from './objectToKey'\nexport {default as retry} from './retry'\nexport {default as uniqueElementsFromArray} from './uniqueElementsFromArray'\nexport {crypto, encoding}\n","import {IdToken} from '@uauth/common'\nimport {jwtVerify, createRemoteJWKSet} from 'jose'\n\nconst verifyIdToken = async (\n  jwks_uri: string,\n  id_token: string,\n  nonce: string,\n  client_id: string,\n) => {\n  const {payload} = await jwtVerify(\n    id_token,\n    createRemoteJWKSet(new URL(jwks_uri)),\n    {audience: client_id},\n  )\n\n  const idToken: IdToken = payload as any\n\n  idToken.__raw = id_token\n\n  if (nonce !== idToken.nonce) {\n    throw new Error(\"nonces don't match\")\n  }\n\n  return idToken\n}\n\nexport default verifyIdToken\n","import fromBase64 from './fromBase64'\n\nconst decodeState = <T>(state: string): T => {\n  const [, v, ...b] = state.split('.')\n\n  if (b.length > 0) {\n    throw new Error('failed to decode state')\n  }\n\n  return v?.length > 0\n    ? JSON.parse(decodeURIComponent(/* unescape */ fromBase64(v)))\n    : undefined\n}\n\nexport default decodeState\n","import getRandomBytes from '../crypto/getRandomBytes'\nimport stringFromBuffer from './stringFromBuffer'\nimport toUrlEncodedBase64 from './toUrlEncodedBase64'\n\nconst encodeState = <T>(state: T): string =>\n  `${toUrlEncodedBase64(stringFromBuffer(getRandomBytes(32)))}.${\n    state == null\n      ? ''\n      : toUrlEncodedBase64(\n          /* escape */ encodeURIComponent(JSON.stringify(state)),\n        )\n  }`\n\nexport default encodeState\n","export default function objectFromEntries<T = any>(\n  entries: Iterable<readonly [PropertyKey, T]>,\n): Record<PropertyKey, T> {\n  const object: Record<PropertyKey, T> = {}\n  for (const [k, v] of entries) {\n    object[k] = v\n  }\n  return object\n}\n","function retry<T>(\n  fn: () => Promise<T>,\n  retries = 4,\n  timeout = 250,\n  factor = 2,\n  err = null,\n): Promise<T> {\n  if (retries <= 0) {\n    return Promise.reject(err)\n  }\n\n  return fn().catch(async err => {\n    await new Promise(r => setTimeout(r, timeout))\n    return retry(fn, retries - 1, timeout * factor, factor, err)\n  })\n}\n\nexport default retry\n","import {ErrorResponse} from './types'\n\nexport default class ApiError extends Error {\n  constructor(\n    public code: string,\n    public description: string,\n    public uri?: string,\n  ) {\n    super(`${code}: ${description}${uri ? `\\nSee more at ${uri}.` : ''}`)\n  }\n\n  static fromResponse(response: ErrorResponse) {\n    return new ApiError(\n      response.error,\n      response.error_description,\n      response.error_uri,\n    )\n  }\n}\n","import {PopupClosedError, PopupTimeoutError} from '../errors/errors'\nimport {UserInfo} from '../types'\nimport {objectFromURLSearchParams} from '../util'\nimport toBase64 from '../util/encoding/toBase64'\nimport ApiError from './ApiError'\nimport {\n  ApiOptions,\n  AuthorizeRequest,\n  AuthorizeResponse,\n  AuthorizeWithDeviceRequest,\n  AuthorizeWithDeviceResponse,\n  BaseRequest,\n  IntrospectRequest,\n  IntrospectResponse,\n  JWKSRequest,\n  JWKSResponse,\n  LogoutRequest,\n  PopupConfig,\n  RevokeRequest,\n  TokenRequest,\n  TokenResponse,\n  TokenWithAuthorizationCodeRequest,\n  TokenWithClientCredentialsRequest,\n  TokenWithDeviceCodeRequest,\n  TokenWithPasswordRequest,\n  TokenWithRefreshTokenRequest,\n  TokenWithSAMLRequest,\n  UserInfoRequest,\n} from './types'\n\nexport default class Api {\n  static Error = ApiError\n\n  constructor(public options: ApiOptions) {}\n\n  buildAuthorizeUrl(request: AuthorizeRequest): string {\n    return this._buildUrl(request)\n  }\n\n  buildLogoutUrl(request: LogoutRequest): string {\n    return this._buildUrl(request)\n  }\n\n  parseAuthorizeResponseFromFragment(url: string): AuthorizeResponse {\n    return this._validateResponse(\n      objectFromURLSearchParams(\n        new URLSearchParams(new URL(url).hash.substring(1)),\n      ),\n    )\n  }\n\n  parseAuthorizeResponseFromQuery(url: string): AuthorizeResponse {\n    return this._validateResponse(\n      objectFromURLSearchParams(new URL(url).searchParams),\n    )\n  }\n\n  async authorizeWithPopup(\n    request: AuthorizeRequest,\n    config: PopupConfig = {},\n  ): Promise<AuthorizeResponse> {\n    if (!window) {\n      throw new Error('no window in options')\n    }\n\n    const url = this.buildAuthorizeUrl(request)\n\n    let popup: Window | undefined | null = config.popup\n    const timeout: number = config.timeout ?? 3600000\n\n    if (!popup) {\n      const width = config.width ?? 600\n      const height = config.height ?? 800\n\n      popup = window.open(\n        url,\n        'uauth:authorize:popup',\n        `left=${window.screenX + (window.innerWidth - width) / 2},top=${\n          window.screenY + (window.innerHeight - height) / 2\n        },width=${width},height=${height},resizable,scrollbars=yes,status=1`,\n      )\n\n      if (!popup) {\n        throw new Error('popup failed to be constructed')\n      }\n    } else {\n      popup.location.href = url\n    }\n\n    let recievedMessage = false\n    const response: AuthorizeResponse = await new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        if (!recievedMessage) {\n          clearInterval(intervalId)\n          popup!.close()\n          reject(new PopupTimeoutError())\n        }\n      }, timeout)\n\n      const intervalId = setInterval(() => {\n        // Check if popup is closed\n        if (!recievedMessage && popup?.closed) {\n          clearInterval(intervalId)\n          clearTimeout(timeoutId)\n          reject(new PopupClosedError())\n        }\n\n        // Check if popup doesn't violate the \"Same-Origin\" policy and has a valid url\n        let href: string\n        let url: URL\n        let redirectUrl: URL\n        try {\n          href = popup!.location.href\n          url = new URL(href)\n          redirectUrl = new URL(request.redirect_uri)\n        } catch (error) {\n          return // Exit if not\n        }\n\n        // Check to see that the redirect was correct\n        url.hash = ''\n        if (url.href === redirectUrl.href) {\n          recievedMessage = true\n\n          clearInterval(intervalId)\n          clearTimeout(timeoutId)\n          popup!.close()\n\n          try {\n            resolve(this.parseAuthorizeResponseFromFragment(href))\n          } catch (error) {\n            reject(error)\n          }\n        }\n      }, 10)\n    })\n\n    return response\n  }\n\n  async authorizeWithDevice(\n    request: AuthorizeWithDeviceRequest,\n  ): Promise<AuthorizeWithDeviceResponse> {\n    return {} as any\n  }\n\n  async getToken(request: TokenRequest): Promise<TokenResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    return this._fetchJSON(input, init)\n  }\n\n  introspect(request: IntrospectRequest): Promise<IntrospectResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    return this._fetchJSON(input, init)\n  }\n\n  async revoke(request: RevokeRequest): Promise<void> {\n    const [input, init] = this._buildRequest(request, {method: 'POST'})\n    await this._fetchJSON(input, init)\n  }\n\n  userinfo(request: UserInfoRequest): Promise<UserInfo> {\n    const [input, init] = this._buildRequest(request, {\n      method: 'GET',\n      headers: {Authorization: `Basic ${request.access_token}`},\n    })\n    return this._fetchJSON(input, init)\n  }\n\n  jwks(request: JWKSRequest): Promise<JWKSResponse> {\n    const [input, init] = this._buildRequest(request, {method: 'GET'})\n    return this._fetchJSON(input, init)\n  }\n\n  getTokenWithAuthorizationCode(\n    request: TokenWithAuthorizationCodeRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithRefreshToken(\n    request: TokenWithRefreshTokenRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithDeviceCode(\n    request: TokenWithDeviceCodeRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithPassword(\n    request: TokenWithPasswordRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithSAML(request: TokenWithSAMLRequest): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  getTokenWithClientCredentials(\n    request: TokenWithClientCredentialsRequest,\n  ): Promise<TokenResponse> {\n    return this.getToken(request)\n  }\n\n  private _buildUrl(request: BaseRequest): string {\n    const {url, ...searchParams} = request\n\n    const urlObject = new URL(url)\n\n    const params = new URLSearchParams()\n\n    for (const [k, v] of Object.entries(searchParams)) {\n      if (k != null && v != null) {\n        params.append(k, v)\n      }\n    }\n\n    urlObject.search = params.toString()\n    return urlObject.toString()\n  }\n\n  private _buildRequest(\n    request: BaseRequest,\n    options: {method: 'GET' | 'POST'; headers?: HeadersInit},\n  ): [RequestInfo, RequestInit] {\n    const {url, client_id, client_secret, client_auth_method, ...rest} = request\n    const {headers: headersInit, method} = options\n\n    const headers = new Headers(this.options.headers ?? [])\n\n    new Headers(headersInit ?? []).forEach((value, key) => {\n      headers.set(key, value)\n    })\n\n    if (options.method === 'POST') {\n      headers.set('Content-Type', 'application/x-www-form-urlencoded')\n    }\n\n    const body: Record<string, any> = {\n      client_id,\n      ...rest,\n    }\n\n    switch (client_auth_method) {\n      case 'client_secret_basic':\n        // throw new Error('only client_secret_post supported')\n        if (client_secret == null) {\n          throw new Error('Client secret not present!')\n        }\n\n        headers.set(\n          'Authorization',\n          `Basic ${toBase64(`${client_id}:${client_secret}`)}`,\n        )\n\n        break\n      case 'client_secret_post':\n        if (client_secret == null) {\n          throw new Error('Client secret not present!')\n        }\n\n        body.client_secret = client_secret\n\n        break\n      case 'none':\n      case undefined:\n      case null:\n        break\n      default:\n        throw new Error('Bad client_auth_method')\n    }\n\n    return [\n      url,\n      {\n        method,\n        headers,\n        body:\n          method === 'POST'\n            ? new URLSearchParams(Object.entries(body))\n            : undefined,\n      },\n    ]\n  }\n\n  private _validateResponse(response: any) {\n    if (response.error) {\n      throw Api.Error.fromResponse(response)\n    }\n\n    return response\n  }\n\n  private async _fetchJSON(\n    input: RequestInfo,\n    init: RequestInit,\n  ): Promise<any> {\n    if (init.headers) {\n      const headers = new Headers(init.headers)\n      headers.set('Accept', 'application/json')\n      init.headers = headers\n    } else {\n      init.headers = {Accept: 'application/json'}\n    }\n\n    const response = await window?.fetch(input, init)\n\n    const json = await response.json()\n    this._validateResponse(json)\n\n    if (!response.ok) {\n      throw new Error(\n        `${response.status} ${response.statusText}: ${JSON.stringify(json)}`,\n      )\n    }\n\n    return json\n  }\n}\n","import {AuthorizeRequest, LogoutRequest} from './api'\nimport type Client from './Client'\nimport {Authorization, AuthorizationOptions} from './types'\nimport * as util from './util'\n\nclass ClientStore {\n  constructor(public client: Client) {}\n\n  private async get<T>(\n    key: string,\n    {mustExist = false, deleteAfter = false} = {},\n  ): Promise<T | undefined> {\n    const entry = await this.client.getStore().get(key)\n    if (entry == null) {\n      if (mustExist) {\n        throw new Error(`${key} does not exist in store`)\n      }\n      return\n    }\n\n    const {value, expiresAt} = entry\n    if (expiresAt !== 0 && expiresAt < Date.now()) {\n      await this.client.getStore().delete(key)\n      if (mustExist) {\n        throw new Error(`${key} does not exist in store`)\n      }\n      return\n    }\n\n    if (deleteAfter) {\n      await this.client.getStore().delete(key)\n    }\n\n    return value\n  }\n\n  private async set<T>(key: string, value: any, timeout = 0) {\n    await this.client.getStore().set(key, {\n      expiresAt: timeout === 0 ? 0 : Date.now() + timeout,\n      value,\n    })\n  }\n\n  async setAuthorizeRequest(request: AuthorizeRequest): Promise<void> {\n    await this.set('request', request, 300_000 /* 5 minutes */)\n  }\n  getAuthorizeRequest(): Promise<AuthorizeRequest> {\n    return this.get<AuthorizeRequest>('request', {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<AuthorizeRequest>\n  }\n\n  async setLogoutRequest(request: LogoutRequest): Promise<void> {\n    await this.set('logout-request', request, 300_000 /* 5 minutes */)\n  }\n  getLogoutRequest(): Promise<LogoutRequest> {\n    return this.get<LogoutRequest>('logout-request', {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<LogoutRequest>\n  }\n\n  async setVerifier(challenge: string, verifier: string): Promise<void> {\n    await this.set(`verifier:${challenge}`, verifier, 300_000 /* 5 minutes */)\n  }\n  getVerifier(challenge: string): Promise<string> {\n    return this.get(`verifier:${challenge}`, {\n      mustExist: true,\n      deleteAfter: true,\n    }) as Promise<string>\n  }\n\n  async setOpenIdConfiguration(\n    username: string,\n    openidConfiguration: any,\n    timeout: number,\n  ): Promise<void> {\n    await this.set(\n      `openidConfiguration:${username}`,\n      openidConfiguration,\n      timeout,\n    )\n  }\n  getOpenIdConfiguration(username: string): Promise<any> {\n    return this.get(`openidConfiguration:${username}`)\n  }\n\n  async setAuthorization(authorization: Authorization): Promise<void> {\n    const authorizationOptions: AuthorizationOptions = {\n      clientID: authorization.idToken.aud,\n      resource: authorization.resource,\n      scope: authorization.scope,\n      username: authorization.idToken.sub,\n    }\n\n    const expiresIn = authorization.expiresAt - Date.now()\n\n    await this.set('username', authorizationOptions.username, expiresIn)\n    await this.set(\n      await this._getAuthorizationKey(authorizationOptions),\n      authorization,\n      expiresIn,\n    )\n  }\n  async deleteAuthorization(options: AuthorizationOptions): Promise<boolean> {\n    const fallbackUsername = await this.get<string>('username')\n\n    options.username = await this._getUsername(\n      options.username,\n      fallbackUsername,\n    )\n\n    if (options.username === fallbackUsername) {\n      await this.client.getStore().delete('username')\n    }\n\n    return this.client\n      .getStore()\n      .delete(await this._getAuthorizationKey(options))\n  }\n  async getAuthorization(\n    options: AuthorizationOptions,\n  ): Promise<Authorization> {\n    return this.get(await this._getAuthorizationKey(options), {\n      mustExist: true,\n    }) as Promise<Authorization>\n  }\n\n  private async _getAuthorizationKey(\n    options: AuthorizationOptions,\n  ): Promise<string> {\n    return `authorization?${util.objectToKey({\n      username: await this._getUsername(\n        options.username,\n        await this.get('username'),\n      ),\n      clientID: options.clientID ?? this.client.fallbackLoginOptions.clientID,\n      scope: util.getSortedScope(\n        options.scope ?? this.client.fallbackLoginOptions.scope,\n      ),\n      resource: options.resource ?? this.client.fallbackLoginOptions.resource,\n    })}`\n  }\n\n  private async _getUsername(username?: string, fallbackUsername?: string) {\n    if (username == null && fallbackUsername == null) {\n      throw new Error('no username given')\n    }\n\n    return username ?? fallbackUsername\n  }\n}\n\nexport default ClientStore\n","import {Store} from './types'\n\nexport default class StorageStore implements Store {\n  constructor(public storage: Storage) {}\n\n  get(key: string): string | null {\n    const value = this.storage.getItem(key)\n\n    if (value != null) {\n      return JSON.parse(value)\n    }\n\n    return null\n  }\n\n  delete(key: string): boolean {\n    this.storage.removeItem(key)\n    return true\n  }\n\n  set(key: string, value): this {\n    this.storage.setItem(key, JSON.stringify(value))\n    return this\n  }\n}\n","import {\n  DefaultIPFSResolver,\n  DefaultIssuerResolver,\n  DefaultWebFingerResolver,\n  DomainResolver,\n  IssuerResolver,\n} from '@uauth/common'\nimport {\n  Resolution,\n  ResolutionError,\n  ResolutionErrorCode,\n} from '@unstoppabledomains/resolution'\nimport {\n  Api,\n  AuthorizeRequest,\n  AuthorizeResponse,\n  LogoutRequest,\n  LogoutResponse,\n  PopupConfig,\n  TokenResponse,\n  TokenWithAuthorizationCodeRequest,\n  UserInfoRequest,\n} from './api'\nimport ClientStore from './ClientStore'\nimport {StorageStore, Store, StoreType} from './store'\nimport {\n  Authorization,\n  AuthorizationOptions,\n  VerifiedAddress,\n  BaseLoginOptions,\n  BaseLogoutOptions,\n  CacheOptions,\n  ClientOptions,\n  FullLoginOptions,\n  LoginCallbackOptions,\n  LoginCallbackResponse,\n  LoginOptions,\n  LogoutCallbackOptions,\n  LogoutOptions,\n  UserInfo,\n  UserOptions,\n} from './types'\nimport * as util from './util'\nimport {VERSION} from './version'\n\nif (typeof window !== 'undefined') {\n  const _w = window as any\n  _w.UAUTH_VERSION = _w.UAUTH_VERSION || {}\n  _w.UAUTH_VERSION.JS = VERSION\n}\n\nexport default class Client {\n  util = util\n  private _clientStore = new ClientStore(this)\n  api: Api\n  fallbackIssuer: string\n  fallbackLoginOptions: BaseLoginOptions\n  fallbackLogoutOptions: BaseLogoutOptions\n  cacheOptions: CacheOptions\n  issuerResolver: IssuerResolver\n  resolution: DomainResolver\n\n  store?: Store\n  storeOptions: {\n    store?: Store\n    storeType: StoreType\n  }\n\n  getStore(): Store {\n    if (this.store) {\n      return this.store\n    }\n\n    if (this.storeOptions.store) {\n      this.store = this.storeOptions.store\n    } else {\n      const storeType = this.storeOptions.storeType\n      switch (storeType) {\n        case 'localstore':\n          this.store = new StorageStore(window.localStorage)\n          break\n        case 'sessionstore':\n          this.store = new StorageStore(window.sessionStorage)\n          break\n        case 'memory':\n          this.store = new Map<string, string>()\n          break\n        default:\n          throw new Error('Bad storeType provided')\n      }\n    }\n\n    return this.store\n  }\n\n  constructor(options: ClientOptions) {\n    this.fallbackIssuer =\n      options.fallbackIssuer ?? 'https://auth.unstoppabledomains.com'\n    this.resolution = options.resolution ?? new Resolution()\n\n    this.storeOptions = {\n      store: options.store,\n      storeType: options.storeType ?? 'localstore',\n    }\n\n    this.cacheOptions = {\n      issuer: false,\n      userinfo: true,\n      ...(options.cacheOptions ?? {}),\n    }\n\n    this.api = new Api({\n      headers: {},\n    })\n\n    this.fallbackLoginOptions = {\n      clientID: options.clientID,\n      clientSecret: options.clientSecret,\n      clientAuthMethod:\n        options.clientAuthMethod ??\n        (options.clientSecret ? 'client_secret_post' : 'none'),\n      maxAge: options.maxAge ?? 300000,\n      prompt: options.prompt ?? 'login',\n      resource: options.resource,\n      redirectUri: options.redirectUri,\n      responseMode: options.responseMode ?? 'fragment',\n      scope: options.scope ?? 'openid wallet',\n    }\n\n    this.fallbackLogoutOptions = {\n      rpInitiatedLogout:\n        options.rpInitiatedLogout ??\n        typeof options.postLogoutRedirectUri === 'string',\n      postLogoutRedirectUri: options.postLogoutRedirectUri,\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this\n    this.issuerResolver = new DefaultIssuerResolver({\n      webfingerResolver: new DefaultWebFingerResolver({\n        ipfsResolver: new DefaultIPFSResolver((...args) =>\n          (options.createIpfsUrl || DefaultIPFSResolver.defaultCreateUrl)(\n            ...args,\n          ),\n        ),\n        domainResolver: {\n          async records(\n            domain: string,\n            keys: string[],\n          ): Promise<Record<string, string>> {\n            try {\n              const records = await self.resolution.records(domain, keys)\n              return records\n            } catch (error) {\n              if (\n                error instanceof ResolutionError &&\n                error.code === ResolutionErrorCode.UnspecifiedResolver\n              ) {\n                return {}\n              }\n              throw error\n            }\n          },\n        },\n      }),\n    })\n  }\n\n  async buildAuthorizeRequest(\n    options: Partial<LoginOptions>,\n  ): Promise<AuthorizeRequest> {\n    // TODO: Ensure nothing is missing\n    const loginOptions: FullLoginOptions = {\n      ...this.fallbackLoginOptions,\n      ...options,\n    } as FullLoginOptions\n\n    const loginHint = options.username\n\n    const openidConfiguration = await this.getOpenIdConfiguration(loginHint)\n\n    const {verifier, challenge} =\n      await util.crypto.createCodeChallengeAndVerifier(43, 'S256')\n\n    const nonce = util.encoding.toBase64(\n      util.encoding.stringFromBuffer(util.crypto.getRandomBytes(32)),\n\n      /* util.encoding.textDecoder.decode */\n    )\n\n    const state = util.encoding.encodeState(loginOptions.state)\n\n    const request: AuthorizeRequest = {\n      // Generated options\n      url: openidConfiguration.authorization_endpoint,\n      code_challenge: challenge,\n      nonce,\n      state,\n\n      // Builder options\n      flow_id: loginOptions.flowId ?? 'login',\n      login_hint: loginHint,\n\n      // Parameterized options\n      client_id: loginOptions.clientID,\n      client_secret: loginOptions.clientSecret,\n      client_auth_method: loginOptions.clientAuthMethod,\n      max_age: loginOptions.maxAge,\n      prompt: loginOptions.prompt,\n      resource: loginOptions.resource,\n      redirect_uri: loginOptions.redirectUri,\n      response_mode: loginOptions.responseMode,\n      scope: loginOptions.scope,\n\n      // Constant options\n      code_challenge_method: 'S256',\n      response_type: 'code',\n\n      // package info\n      package_name: loginOptions?.packageName || '@uauth/js',\n      package_version: loginOptions?.packageVersion || VERSION,\n    }\n\n    await this._clientStore.setAuthorizeRequest(request)\n    await this._clientStore.setVerifier(challenge, verifier)\n\n    return request\n  }\n\n  async loginWithPopup(\n    options: Partial<Omit<LoginOptions, 'responseMode'>> = {},\n    config?: PopupConfig,\n  ): Promise<Authorization> {\n    ;(options as Partial<LoginOptions>).responseMode = 'fragment'\n    const request = await this.buildAuthorizeRequest(options)\n    const response = await this.api.authorizeWithPopup(request, config)\n    const authorization = await this.verifyAuthorizeResponse(request, response)\n\n    return authorization\n  }\n\n  async login(options: Partial<LoginOptions> = {}): Promise<void> {\n    const request: AuthorizeRequest = await this.buildAuthorizeRequest(options)\n\n    const url = this.api.buildAuthorizeUrl(request)\n\n    if (typeof options.beforeRedirect === 'function') {\n      await options.beforeRedirect(url)\n    }\n\n    window.location.href = url\n  }\n\n  async loginCallback<T>(\n    options?: Partial<LoginCallbackOptions>,\n  ): Promise<LoginCallbackResponse<T>> {\n    const url = options?.url ?? window.location.href\n\n    const request: AuthorizeRequest =\n      await this._clientStore.getAuthorizeRequest()\n\n    let response: AuthorizeResponse\n    if (request.response_mode === 'fragment') {\n      response = this.api.parseAuthorizeResponseFromFragment(url)\n    } else if (request.response_mode === 'query') {\n      response = this.api.parseAuthorizeResponseFromQuery(url)\n    } else {\n      throw new Error('Unsupported response_mode')\n    }\n\n    return {\n      authorization: await this.verifyAuthorizeResponse(request, response),\n      state: util.encoding.decodeState<T>(request.state),\n    }\n  }\n\n  async verifyAuthorizeResponse(\n    request: AuthorizeRequest,\n    response: AuthorizeResponse,\n  ): Promise<Authorization> {\n    if (request.state !== response.state) {\n      throw new Error(\"states don't match\")\n    }\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      request.login_hint,\n    )\n\n    const tokenRequest: TokenWithAuthorizationCodeRequest = {\n      url: openidConfiguration.token_endpoint,\n      client_id: request.client_id,\n      client_secret: request.client_secret,\n      client_auth_method: request.client_auth_method,\n      grant_type: 'authorization_code',\n      code: response.code,\n      code_verifier: await this._clientStore.getVerifier(\n        request.code_challenge,\n      ),\n      redirect_uri: request.redirect_uri,\n    }\n\n    const tokenResponse: TokenResponse =\n      await this.api.getTokenWithAuthorizationCode(tokenRequest)\n\n    const idToken = await util.crypto.verifyIdToken(\n      openidConfiguration.jwks_uri,\n      tokenResponse.id_token!,\n      request.nonce,\n      request.client_id,\n    )\n\n    const authorization: Authorization = {\n      accessToken: tokenResponse.access_token,\n      // TODO: The server isn't returning the scope along with the callback and\n      // I havn't found the oidc docs to figure out if this is a bug.\n      expiresAt: Date.now() + tokenResponse.expires_in * 1000,\n      idToken,\n      scope: util.getSortedScope(request.scope),\n      resource: request.resource,\n    }\n\n    await this._clientStore.setAuthorization(authorization)\n\n    return authorization\n  }\n\n  // getVerifiedAccounts retrieves all verified accounts associated with the domain\n  getVerifiedAccounts(\n    authorization: Authorization,\n    symbols: string[] = [],\n  ): VerifiedAddress[] {\n    // ensure the authorization includes verified_addresses field\n    const verifiedAddresses: VerifiedAddress[] = []\n    if (!authorization.idToken.verified_addresses) {\n      return verifiedAddresses\n    }\n    authorization.idToken.verified_addresses.forEach((record: any) => {\n      // filter for requested symbols if provided\n      if (symbols.length > 0 && !symbols.includes(record.symbol)) {\n        return\n      }\n      // include the verified address\n      verifiedAddresses.push({\n        address: record.address,\n        message: record.proof.message,\n        signature: record.proof.signature,\n        symbol: record.symbol,\n      })\n    })\n\n    // return the verified address list\n    return verifiedAddresses\n  }\n\n  // getAuthorizationAccount retrieves the address that authorized the request\n  getAuthorizationAccount(\n    authorization: Authorization,\n    type = 'sig',\n    version = 'v1',\n  ): VerifiedAddress | undefined {\n    // find the requested proof key from AMR field\n    const sigProofKeys = authorization.idToken.amr?.filter((key: string) =>\n      key.startsWith(`${version}.${type}`),\n    )\n\n    // validate the proof key is located\n    if (!sigProofKeys || sigProofKeys.length == 0) {\n      return undefined\n    }\n\n    // extract the signature address\n    const sigAddress = sigProofKeys[0].split('.')[3]\n    const verifiedAccounts = this.getVerifiedAccounts(authorization)\n    if (!verifiedAccounts) {\n      return undefined\n    }\n\n    // find and return the proof address from verified account list\n    for (const account of verifiedAccounts) {\n      if (account.address === sigAddress) {\n        return account\n      }\n    }\n  }\n\n  async getOpenIdConfiguration(username?: string): Promise<any> {\n    if (this.cacheOptions.issuer) {\n      const openidConfiguration =\n        await this._clientStore.getOpenIdConfiguration(username ?? '')\n      if (openidConfiguration) {\n        return openidConfiguration\n      }\n    }\n\n    const openidConfiguration = username\n      ? await this.issuerResolver.resolve(username, this.fallbackIssuer)\n      : await fetch(\n          this.fallbackIssuer + '/.well-known/openid-configuration',\n        ).then(resp =>\n          resp.ok\n            ? resp.json()\n            : Promise.reject(new Error('bad openid-configuration response')),\n        )\n\n    await this._clientStore.setOpenIdConfiguration(\n      username ?? '',\n      openidConfiguration,\n      typeof this.cacheOptions.issuer === 'number'\n        ? this.cacheOptions.issuer\n        : 3600_000,\n    )\n\n    return openidConfiguration\n  }\n\n  async authorization(\n    options: AuthorizationOptions = {},\n  ): Promise<Authorization> {\n    return this._clientStore.getAuthorization(options)\n  }\n\n  async user(options: UserOptions = {}): Promise<UserInfo> {\n    const claims = options.claims ?? [\n      'name',\n      'given_name',\n      'family_name',\n      'middle_name',\n      'nickname',\n      'preferred_username',\n      'profile',\n      'picture',\n      'website',\n      'email',\n      'email_verified',\n      'gender',\n      'birthdate',\n      'zoneinfo',\n      'locale',\n      'phone_number',\n      'phone_number_verified',\n      'address',\n      'updated_at',\n      'wallet_address',\n      'wallet_type_hint',\n      'eip4361_message',\n      'eip4361_signature',\n      'humanity_check_id',\n    ]\n\n    const authorization = await this.authorization(options)\n\n    const userinfo: UserInfo = {\n      sub: authorization.idToken.sub,\n    }\n\n    // If we should only read from cache.\n    if (this.cacheOptions.userinfo) {\n      for (const claim of claims) {\n        if (authorization.idToken[claim]) {\n          userinfo[claim] = authorization.idToken[claim]\n        }\n      }\n\n      return userinfo\n    }\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      authorization.idToken.sub,\n    )\n\n    const request: UserInfoRequest = {\n      client_id: this.fallbackLoginOptions.clientID,\n      client_secret: this.fallbackLoginOptions.clientSecret,\n      client_auth_method: this.fallbackLoginOptions.clientAuthMethod,\n      access_token: authorization.accessToken,\n      url: openidConfiguration.userinfo_endpoint,\n    }\n\n    const response = await this.api.userinfo(request)\n\n    for (const claim of claims) {\n      if (response[claim]) {\n        userinfo[claim] = response[claim]\n      }\n    }\n\n    return userinfo\n  }\n\n  async buildLogoutRequest(options: LogoutOptions): Promise<LogoutRequest> {\n    const authorization = await this.authorization(options)\n\n    const openidConfiguration = await this.getOpenIdConfiguration(\n      authorization.idToken.sub,\n    )\n\n    if (openidConfiguration.end_session_endpoint == null) {\n      throw new Error('end_session_endpoint must exist')\n    }\n\n    const postLogoutRedirectUri =\n      options.postLogoutRedirectUri ??\n      this.fallbackLogoutOptions.postLogoutRedirectUri\n\n    if (postLogoutRedirectUri == null) {\n      throw new Error('postLogoutRedirectUri must be supplied')\n    }\n\n    const request: LogoutRequest = {\n      client_id: this.fallbackLoginOptions.clientID,\n      client_secret: this.fallbackLoginOptions.clientSecret,\n      client_auth_method: this.fallbackLoginOptions.clientAuthMethod,\n      url: openidConfiguration.end_session_endpoint,\n      id_token_hint: authorization.idToken.__raw,\n      post_logout_redirect_uri: postLogoutRedirectUri,\n      state: util.encoding.encodeState(options.state),\n    }\n\n    await this._clientStore.setLogoutRequest(request)\n\n    return request\n  }\n\n  async logout({\n    clientID,\n    username,\n    scope,\n    resource,\n    ...options\n  }: Partial<LogoutOptions> = {}): Promise<void> {\n    const logoutOptions: LogoutOptions = {\n      ...this.fallbackLogoutOptions,\n      ...options,\n    }\n\n    const authorizationOptions = {clientID, username, scope, resource}\n\n    if (!logoutOptions.rpInitiatedLogout) {\n      await this._clientStore.deleteAuthorization(authorizationOptions)\n      return\n    }\n\n    const request = await this.buildLogoutRequest(logoutOptions)\n\n    const url = this.api.buildLogoutUrl(request)\n\n    if (typeof logoutOptions.beforeRedirect === 'function') {\n      await logoutOptions.beforeRedirect(url)\n    }\n\n    await this._clientStore.deleteAuthorization(authorizationOptions)\n\n    window.location.href = url\n  }\n\n  async logoutCallback<T>(options: LogoutCallbackOptions = {}): Promise<T> {\n    const url = options?.url ?? window.location.href\n\n    const request: LogoutRequest = await this._clientStore.getLogoutRequest()\n\n    const response: AuthorizeResponse =\n      this.api.parseAuthorizeResponseFromQuery(url)\n\n    await this.verifyLogoutResponse(request, response)\n\n    return util.encoding.decodeState<T>(request.state)\n  }\n\n  async verifyLogoutResponse(\n    request: LogoutRequest,\n    response: LogoutResponse,\n  ): Promise<void> {\n    if (request.state !== response.state) {\n      throw new Error(\"states don't match\")\n    }\n  }\n}\n","export const VERSION = \"2.4.0\";\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}