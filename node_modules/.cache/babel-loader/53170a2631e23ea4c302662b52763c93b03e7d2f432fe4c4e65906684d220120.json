{"ast":null,"code":"import \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\nfunction createEncoder(writer) {\n  return {\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n    async writeBlock(block) {\n      const {\n        cid,\n        bytes\n      } = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n      if (bytes.length) {\n        await writer.write(bytes);\n      }\n    },\n    async close() {\n      return writer.end();\n    }\n  };\n}\nexport { createEncoder };","map":{"version":3,"names":["varint","encode","dagCborEncode","createHeader","roots","headerBytes","version","varintBytes","length","header","Uint8Array","set","createEncoder","writer","setRoots","bytes","write","writeBlock","block","cid","close","end"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/@ipld/car/esm/lib/encoder.js"],"sourcesContent":["import varint from 'varint';\nimport { encode as dagCborEncode } from '@ipld/dag-cbor';\nexport function createHeader(roots) {\n  const headerBytes = dagCborEncode({\n    version: 1,\n    roots\n  });\n  const varintBytes = varint.encode(headerBytes.length);\n  const header = new Uint8Array(varintBytes.length + headerBytes.length);\n  header.set(varintBytes, 0);\n  header.set(headerBytes, varintBytes.length);\n  return header;\n}\nfunction createEncoder(writer) {\n  return {\n    async setRoots(roots) {\n      const bytes = createHeader(roots);\n      await writer.write(bytes);\n    },\n    async writeBlock(block) {\n      const {cid, bytes} = block;\n      await writer.write(new Uint8Array(varint.encode(cid.bytes.length + bytes.length)));\n      await writer.write(cid.bytes);\n      if (bytes.length) {\n        await writer.write(bytes);\n      }\n    },\n    async close() {\n      return writer.end();\n    }\n  };\n}\nexport {\n  createEncoder\n};"],"mappings":";;AAAA,OAAOA,MAAM,MAAM,QAAQ;AAC3B,SAASC,MAAM,IAAIC,aAAa,QAAQ,gBAAgB;AACxD,OAAO,SAASC,YAAY,CAACC,KAAK,EAAE;EAClC,MAAMC,WAAW,GAAGH,aAAa,CAAC;IAChCI,OAAO,EAAE,CAAC;IACVF;EACF,CAAC,CAAC;EACF,MAAMG,WAAW,GAAGP,MAAM,CAACC,MAAM,CAACI,WAAW,CAACG,MAAM,CAAC;EACrD,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAACH,WAAW,CAACC,MAAM,GAAGH,WAAW,CAACG,MAAM,CAAC;EACtEC,MAAM,CAACE,GAAG,CAACJ,WAAW,EAAE,CAAC,CAAC;EAC1BE,MAAM,CAACE,GAAG,CAACN,WAAW,EAAEE,WAAW,CAACC,MAAM,CAAC;EAC3C,OAAOC,MAAM;AACf;AACA,SAASG,aAAa,CAACC,MAAM,EAAE;EAC7B,OAAO;IACL,MAAMC,QAAQ,CAACV,KAAK,EAAE;MACpB,MAAMW,KAAK,GAAGZ,YAAY,CAACC,KAAK,CAAC;MACjC,MAAMS,MAAM,CAACG,KAAK,CAACD,KAAK,CAAC;IAC3B,CAAC;IACD,MAAME,UAAU,CAACC,KAAK,EAAE;MACtB,MAAM;QAACC,GAAG;QAAEJ;MAAK,CAAC,GAAGG,KAAK;MAC1B,MAAML,MAAM,CAACG,KAAK,CAAC,IAAIN,UAAU,CAACV,MAAM,CAACC,MAAM,CAACkB,GAAG,CAACJ,KAAK,CAACP,MAAM,GAAGO,KAAK,CAACP,MAAM,CAAC,CAAC,CAAC;MAClF,MAAMK,MAAM,CAACG,KAAK,CAACG,GAAG,CAACJ,KAAK,CAAC;MAC7B,IAAIA,KAAK,CAACP,MAAM,EAAE;QAChB,MAAMK,MAAM,CAACG,KAAK,CAACD,KAAK,CAAC;MAC3B;IACF,CAAC;IACD,MAAMK,KAAK,GAAG;MACZ,OAAOP,MAAM,CAACQ,GAAG,EAAE;IACrB;EACF,CAAC;AACH;AACA,SACET,aAAa"},"metadata":{},"sourceType":"module","externalDependencies":[]}