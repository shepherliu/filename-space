{"ast":null,"code":"import \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport { CarReader, CarWriter } from '@ipld/car';\nimport { Block } from 'multiformats/block';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as cbor from '@ipld/dag-cbor';\nimport * as pb from '@ipld/dag-pb';\nexport class TreewalkCarSplitter {\n  constructor(reader, targetSize, options = {}) {\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [pb, raw, cbor, ...(options.decoders || [])];\n  }\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1) throw new Error(`unexpected number of roots: ${roots.length}`);\n    let channel;\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out) yield val.out;\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    channel.writer.close();\n    yield channel.out;\n  }\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock) throw new Error(`missing block for ${cid}`);\n    const {\n      bytes\n    } = rawBlock;\n    const decoder = this._decoders.find(d => d.code === cid.code);\n    if (!decoder) throw new Error(`missing decoder for ${cid.code}`);\n    return new Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n  async *_cars(cid, parents = [], channel = undefined) {\n    const block = await this._get(cid);\n    channel = channel || Object.assign(CarWriter.create(cid), {\n      size: 0\n    });\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {\n        out\n      } = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    yield {\n      channel\n    };\n  }\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n}\nfunction newCar(parents) {\n  const ch = Object.assign(CarWriter.create(parents[0].cid), {\n    size: parents.reduce((size, b) => size + b.bytes.byteLength, 0)\n  });\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n  return ch;\n}","map":{"version":3,"names":["CarReader","CarWriter","Block","raw","cbor","pb","TreewalkCarSplitter","constructor","reader","targetSize","options","Error","_reader","_targetSize","_decoders","decoders","cars","roots","getRoots","length","channel","val","_cars","out","writer","close","_get","cid","rawBlock","get","bytes","decoder","find","d","code","value","decode","parents","undefined","block","Object","assign","create","size","byteLength","newCar","concat","put","links","fromIterable","iterable","fromBlob","blob","buffer","arrayBuffer","fromBytes","Uint8Array","ch","reduce","b"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/carbites/esm/lib/treewalk/splitter.js"],"sourcesContent":["import {\n  CarReader,\n  CarWriter\n} from '@ipld/car';\nimport { Block } from 'multiformats/block';\nimport * as raw from 'multiformats/codecs/raw';\nimport * as cbor from '@ipld/dag-cbor';\nimport * as pb from '@ipld/dag-pb';\nexport class TreewalkCarSplitter {\n  constructor(reader, targetSize, options = {}) {\n    if (typeof targetSize !== 'number' || targetSize <= 0) {\n      throw new Error('invalid target chunk size');\n    }\n    this._reader = reader;\n    this._targetSize = targetSize;\n    this._decoders = [\n      pb,\n      raw,\n      cbor,\n      ...options.decoders || []\n    ];\n  }\n  async *cars() {\n    const roots = await this._reader.getRoots();\n    if (roots.length !== 1)\n      throw new Error(`unexpected number of roots: ${ roots.length }`);\n    let channel;\n    for await (const val of this._cars(roots[0])) {\n      channel = val.channel;\n      if (val.out)\n        yield val.out;\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    channel.writer.close();\n    yield channel.out;\n  }\n  async _get(cid) {\n    const rawBlock = await this._reader.get(cid);\n    if (!rawBlock)\n      throw new Error(`missing block for ${ cid }`);\n    const {bytes} = rawBlock;\n    const decoder = this._decoders.find(d => d.code === cid.code);\n    if (!decoder)\n      throw new Error(`missing decoder for ${ cid.code }`);\n    return new Block({\n      cid,\n      bytes,\n      value: decoder.decode(bytes)\n    });\n  }\n  async *_cars(cid, parents = [], channel = undefined) {\n    const block = await this._get(cid);\n    channel = channel || Object.assign(CarWriter.create(cid), { size: 0 });\n    if (channel.size > 0 && channel.size + block.bytes.byteLength >= this._targetSize) {\n      channel.writer.close();\n      const {out} = channel;\n      channel = newCar(parents);\n      yield {\n        channel,\n        out\n      };\n    }\n    parents = parents.concat(block);\n    channel.size += block.bytes.byteLength;\n    channel.writer.put(block);\n    for (const [, cid] of block.links()) {\n      for await (const val of this._cars(cid, parents, channel)) {\n        channel = val.channel;\n        yield val;\n      }\n    }\n    if (!channel) {\n      throw new Error('missing CAR writer channel');\n    }\n    yield { channel };\n  }\n  static async fromIterable(iterable, targetSize, options) {\n    const reader = await CarReader.fromIterable(iterable);\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n  static async fromBlob(blob, targetSize, options) {\n    const buffer = await blob.arrayBuffer();\n    const reader = await CarReader.fromBytes(new Uint8Array(buffer));\n    return new TreewalkCarSplitter(reader, targetSize, options);\n  }\n}\nfunction newCar(parents) {\n  const ch = Object.assign(CarWriter.create(parents[0].cid), { size: parents.reduce((size, b) => size + b.bytes.byteLength, 0) });\n  for (const b of parents) {\n    ch.writer.put(b);\n  }\n  return ch;\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}