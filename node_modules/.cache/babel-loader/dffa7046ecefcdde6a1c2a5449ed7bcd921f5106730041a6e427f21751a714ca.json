{"ast":null,"code":"var r = /*#__PURE__*/function () {\n    function r(e) {\n      void 0 === e && (e = r.defaultCreateUrl), this.createURL = void 0, this.createURL = e;\n    }\n    return r.defaultCreateUrl = function (r, e) {\n      return \"https://\" + r + \".ipns.dweb.link\" + e.replace(/^\\/?/, \"/\");\n    }, r.prototype.resolve = function (r) {\n      try {\n        var e, t, n;\n        if (r.startsWith(\"/ipfs/\") || r.startsWith(\"/ipns/\")) n = r.substring(1, 5), e = r.substring(6).split(\"/\")[0], t = r.substring(6 + e.length);else {\n          var o = new URL(r);\n          if (\"\" !== o.hash || \"\" !== o.password || \"\" !== o.port || \"\" !== o.search || \"\" !== o.username) throw new Error(\"invalid ipfs uri\");\n          n = o.protocol.substring(0, 4), e = o.hostname, t = o.pathname;\n        }\n        if (\"ipfs\" !== n) throw new Error(\"only ipfs is supported, (not ipns)\");\n        return Promise.resolve(fetch(this.createURL(e, t)).then(function (r) {\n          return r.ok ? r.text() : Promise.reject(new Error(\"bad response\"));\n        }));\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }, r;\n  }(),\n  e = /*#__PURE__*/function () {\n    function r(r) {\n      this.options = void 0, this.options = r;\n    }\n    return r.prototype.resolve = function (r, e) {\n      try {\n        var t,\n          n = \"\";\n        if (r.includes(\"@\")) {\n          var o = r.split(\"@\", 1);\n          n = o[0], t = o[1];\n        } else t = r;\n        var i = \"http://openid.net/specs/connect/1.0/issuer\";\n        return Promise.resolve(this.options.webfingerResolver.resolve(t, n, i, e)).then(function (r) {\n          var e,\n            t = null == (e = r.links) ? void 0 : e.find(function (r) {\n              return r.rel === i;\n            });\n          if (!t || !t.href) throw new Error(\"bad jrd\");\n          return Promise.resolve(fetch(t.href + \"/.well-known/openid-configuration\").then(function (r) {\n            return r.ok ? r.json() : Promise.reject(new Error(\"bad openid-configuration response\"));\n          }));\n        });\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }, r;\n  }();\nfunction t(r) {\n  return !0;\n}\nfunction n(r) {\n  return !0;\n}\nfunction o(r, e, t) {\n  if (!r.s) {\n    if (t instanceof i) {\n      if (!t.s) return void (t.o = o.bind(null, r, e));\n      1 & e && (e = t.s), t = t.v;\n    }\n    if (t && t.then) return void t.then(o.bind(null, r, e), o.bind(null, r, 2));\n    r.s = e, r.v = t;\n    const n = r.o;\n    n && n(r);\n  }\n}\nvar i = /*#__PURE__*/function () {\n  function r() {}\n  return r.prototype.then = function (e, t) {\n    var n = new r(),\n      i = this.s;\n    if (i) {\n      var s = 1 & i ? e : t;\n      if (s) {\n        try {\n          o(n, 1, s(this.v));\n        } catch (r) {\n          o(n, 2, r);\n        }\n        return n;\n      }\n      return this;\n    }\n    return this.o = function (r) {\n      try {\n        var i = r.v;\n        1 & r.s ? o(n, 1, e ? e(i) : i) : t ? o(n, 1, t(i)) : o(n, 2, i);\n      } catch (r) {\n        o(n, 2, r);\n      }\n    }, n;\n  }, r;\n}();\nif (\"undefined\" != typeof window) {\n  var s = window;\n  s.UAUTH_VERSION = s.UAUTH_VERSION || {}, s.UAUTH_VERSION.COMMON = \"2.3.0\";\n}\nvar u = /*#__PURE__*/function () {\n  function r(r) {\n    this.options = void 0, this.options = r;\n  }\n  return r.prototype.resolve = function (r, e, t, n) {\n    try {\n      var s = this,\n        u = \"webfinger.\" + e + \".\" + t;\n      return Promise.resolve(s.options.domainResolver.records(r, [u])).then(function (f) {\n        function c(r) {\n          if (h.subject !== a) throw new Error(\"resource invalid\");\n          return h;\n        }\n        var a = e ? \"acct:\" + e + \"@\" + r : \"\" + r;\n        if (!f[u]) return {\n          subject: a,\n          links: [{\n            rel: t,\n            href: n\n          }]\n        };\n        var h,\n          v = JSON.parse(f[u]),\n          p = \"string\" == typeof v.host ? Promise.resolve(fetch(\"/.well-known/webfinger?\" + new URLSearchParams({\n            resource: a,\n            rel: t\n          }).toString(), {\n            headers: {\n              Host: v.host\n            }\n          }).then(function (r) {\n            return r.ok ? r.json() : Promise.reject(new Error(\"bad webfinger response\"));\n          })).then(function (r) {\n            h = r;\n          }) : function () {\n            if (\"string\" == typeof v.uri) {\n              var r = new URL(v.uri);\n              return function (r, e) {\n                var t,\n                  n = -1;\n                r: {\n                  for (var s = 0; s < e.length; s++) {\n                    var u = e[s][0];\n                    if (u) {\n                      var f = u();\n                      if (f && f.then) break r;\n                      if (f === r) {\n                        n = s;\n                        break;\n                      }\n                    } else n = s;\n                  }\n                  if (-1 !== n) {\n                    do {\n                      for (var c = e[n][1]; !c;) n++, c = e[n][1];\n                      var a = c();\n                      if (a && a.then) {\n                        t = !0;\n                        break r;\n                      }\n                      var h = e[n][2];\n                      n++;\n                    } while (h && !h());\n                    return a;\n                  }\n                }\n                var v = new i(),\n                  p = o.bind(null, v, 2);\n                return (t ? a.then(l) : f.then(function t(i) {\n                  for (;;) {\n                    if (i === r) {\n                      n = s;\n                      break;\n                    }\n                    if (++s === e.length) {\n                      if (-1 !== n) break;\n                      return void o(v, 1, c);\n                    }\n                    if (u = e[s][0]) {\n                      if ((i = u()) && i.then) return void i.then(t).then(void 0, p);\n                    } else n = s;\n                  }\n                  do {\n                    for (var f = e[n][1]; !f;) n++, f = e[n][1];\n                    var c = f();\n                    if (c && c.then) return void c.then(l).then(void 0, p);\n                    var a = e[n][2];\n                    n++;\n                  } while (a && !a());\n                  o(v, 1, c);\n                })).then(void 0, p), v;\n                function l(r) {\n                  for (;;) {\n                    var t = e[n][2];\n                    if (!t || t()) break;\n                    n++;\n                    for (var i = e[n][1]; !i;) n++, i = e[n][1];\n                    if ((r = i()) && r.then) return void r.then(l).then(void 0, p);\n                  }\n                  o(v, 1, r);\n                }\n              }(r.protocol, [[function () {\n                return \"http:\";\n              }], [function () {\n                return \"https:\";\n              }, function () {\n                return Promise.resolve(fetch(r.toString()).then(function (r) {\n                  return r.ok ? r.json() : Promise.reject(new Error(\"bad webfinger response\"));\n                })).then(function (r) {\n                  h = r;\n                });\n              }], [function () {\n                return \"ipfs:\";\n              }, function () {\n                return Promise.resolve(s.options.ipfsResolver.resolve(v.uri)).then(function (r) {\n                  h = JSON.parse(r);\n                });\n              }], [function () {\n                return \"ipns:\";\n              }], [function () {\n                return \"swarm:\";\n              }], [void 0, function () {\n                throw new Error(\"uri scheme not supported\");\n              }]]);\n            }\n            if (\"string\" != typeof v.value) throw new Error(\"bad webfinger record\");\n            h = JSON.parse(v.value);\n          }();\n        return p && p.then ? p.then(c) : c();\n      });\n    } catch (r) {\n      return Promise.reject(r);\n    }\n  }, r;\n}();\nfunction f() {\n  return f = Object.assign || function (r) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var n in t) Object.prototype.hasOwnProperty.call(t, n) && (r[n] = t[n]);\n    }\n    return r;\n  }, f.apply(this, arguments);\n}\nvar c = /*#__PURE__*/function () {\n    function r() {\n      var r = this;\n      this.map = new Map(), this.records = function (e, t) {\n        try {\n          var n = r.map.get(e);\n          if (0 === t.length) throw new Error(\"no keys\");\n          return Promise.resolve(n ? t.reduce(function (r, e) {\n            return r[e] = n[e] || \"\", r;\n          }, {}) : {});\n        } catch (r) {\n          return Promise.reject(r);\n        }\n      };\n    }\n    return r.prototype.set = function (r, e) {\n      this.map.has(r) ? this.map.set(r, f({}, this.map.get(r), e)) : this.map.set(r, e);\n    }, r;\n  }(),\n  a = /*#__PURE__*/function () {\n    function r() {\n      this.map = new Map();\n    }\n    var e = r.prototype;\n    return e.set = function (r, e, t, n) {\n      this.map.set(r + \".\" + e + \".\" + t, n);\n    }, e.resolve = function (r, e, t, n) {\n      try {\n        var o = this.map.get(r + \".\" + e + \".\" + t);\n        return Promise.resolve(o || {\n          subject: r,\n          links: [{\n            rel: t,\n            href: n\n          }]\n        });\n      } catch (r) {\n        return Promise.reject(r);\n      }\n    }, r;\n  }();\nexport { r as DefaultIPFSResolver, e as DefaultIssuerResolver, u as DefaultWebFingerResolver, c as MemoryDomainResolver, a as MemoryWebFingerResolver, n as isJRD, t as isJRDLink };","map":{"version":3,"mappings":"AAEqBA,qBACZC;IAIP,SAAmBC;MAAAA,KAAgD,MAAhDA,UAAYF,EAAoBC,mBAAgBE,KAAhDD,iBAAgD,GAAhDC,KAASD,YAATA;IAAAA;IAAAA,OAJZD,qBAAP,UAAwBG,GAAaC;MACnC,oBAAkBD,IAAlB,oBAAuCC,EAAKC,QAAQ,QAAQ;IAAA,eAKxDC,oBAAQC;MAAAA;QA+BC,IA9BTJ,GACAC,GACAI;QAEJ,IAAID,EAAIE,WAAW,aAAaF,EAAIE,WAAW,WAC7CD,IAAWD,EAAIG,UAAU,GAAG,IAC5BP,IAAMI,EAAIG,UAAU,GAAGC,MAAM,KAAK,IAClCP,IAAOG,EAAIG,UAAU,IAAIP,EAAIS,aACxB;UACL,IAAMC,IAAM,IAAIC,IAAIP;UAEpB,IACe,OAAbM,EAAIE,QACa,OAAjBF,EAAIG,YACS,OAAbH,EAAII,QACW,OAAfJ,EAAIK,UACa,OAAjBL,EAAIM,UAEJ,MAAM,IAAIC,MAAM;UAGlBZ,IAAWK,EAAIL,SAASE,UAAU,GAAG,IACrCP,IAAMU,EAAIQ,UACVjB,IAAOS,EAAIS;QAAAA;QAGb,IAAiB,WAAbd,GACF,MAAUY,UAAM;QAGlB,uBAAOG,MAAMrB,KAAKD,UAAUE,GAAKC,IAAOoB,KAAK;UAAI,OAC/CC,EAAKC,KAAKD,EAAKE,SAASC,QAAQC,OAAO,IAAIT,MAAM;QAAA;MAAA;QAAA;MAAA;IAAA;EAAA,CAtC9CpB;ECDY8B,iBACnB;IAAA,WAAmBC;MAAAA,oBAA8B,GAA9B7B,KAAO6B,UAAPA;IAAAA;IAAAA,mBAEbzB,oBAAQa,GAAkBa;MAAsB;QAAA,IAEhDC;UADAC,IAAO;QAEX,IAAIf,EAASgB,SAAS,MAAM;UAAA,QACRhB,EAASR,MAAM,KAAK;UAApCuB,UAAMD,IADkBG;QAAA,OAG1BH,IAASd;QAGX,IAAMkB,IAAM;QATwC,uBAWlCnC,KAAK6B,QAAQO,kBAAkBhC,QAC/C2B,GACAC,GACAG,GACAL,IAfkDR,eAW9Ce;UAON;YAAMC,IAAO,SAAHC,IAAGF,EAAIG,cAAJ,MAAWC,KAAK;cAAKC,SAAEP,QAAQA;YAAAA;UAC5C,KAAKG,MAASA,EAAKK,MACjB,UAAUzB,MAAM;UApBkC,uBAuB/BG,MACnBiB,EAAKK,OAAO,qCACZrB,KAAK;YAAI,OACTC,EAAKC,KACDD,EAAKqB,SACLlB,QAAQC,OAAO,IAAIT,MAAM;UAAA;QAAA;MAAA;QAAA;MAAA;IAAA;EAAA,CA9BjC;AAAA,SCDc2B,EAAUD;EACxB,QAAO;AAAA;AAGH,SAAUE,EAAMF;EACpB,QACD;AAAA;ACmDa,cAAMG,GAAOC;EACb;IAAA,oBAEC;MACN,UASD,aADAA,mBAAcC;MAPd,UACEF,UAIDC;IAAAN;IAMF,iBACI,YAANM;IAEAC,SAAMA;IACL,UAAUA;IACXC,KAEDA,EAAID;EAAAA;AAAAA;AAhFD,IAASE,iBAAiB;EAEjC;EAAAA,SACQC,UAAK9B,OAAa;IAAA+B;MAERN,SAACO;IAClB;MAEK,IAAQC,IAA+B,IAA/BR,IAA+BS;MACxB;QAAnB;UAAAC,EAA0BC,QAA0B1D;QAAA0C,CAAI;UAEnDiB,KACH,GAAcC;QAAAA;QAAAA,OAOmBF;MAAAA;MAGjC;IAAA;IA2BO,OAvBP1D;MAAA;QAIA,QAAK6D,EAAQnB;QACX,UACDiB,wBAEKN,MAE6CK,cAGnDC,KAA0B;MAAAX,CAGpB;QAIAW,KAAE,GAAKC;MAAAA;IAAAA,GAGNF;EAAAA;AAAAA,CAjDsB;AAEjC,IAAsB,sBAAXI,QAAwB;EACjC,IAAMC,IAAKD;EACXC,EAAGC,gBAAgBD,EAAGC,iBAAiB,IACvCD,EAAGC,cAAcC,SCPI;AAAA;ADUFC;EACnB,WAAmBrC;IAAAA,4BAAOA,UAAPA;EAAAA;EAAAA,OAEbzB,sBACJ2B,aACAC,GACAG,GACAL;IAAAA;MAOsB;QALhBqC,IAAY,eAAgBnC,IAAQG;MAFpB,uBAOAiC,EAAKvC,QAAQwC,eAAeC,QAAQvC,GAAQ,CAChEoC,KADIG;QAAAA;UA8DN,IAAI1B,EAAK2B,YAAYC,GACnB,MAAM,IAAItD,MAAM;UAGlB,OAAO0B;QAAAA;QA9DP,IAAM4B,IAAWxC,IAAI,UAAWA,IAAQD,UAAcA;QAItD,KAAKuC,EAAQH,IACX,OAAO;UAACI,SAASC;UAAUhC,OAAO,CAAC;YAACL;YAAKQ,MAAMb;UAAAA;QAAAA;QAGjD,IAIIc;UAJE6B,IAAmCC,KAAKC,MAAML,EAAQH;UAAAA,IAKxB,mBAAzBM,EAAgBG,OACZvD,sBACX,4BACE,IAAIwD,gBAAgB;YAACL;YAAUrC;UAAAA,GAAM2C,YACvC;YAACC,SAAS;cAACC,MAAMP,EAAgBG;YAAAA;UAAAA,GACjCtD,KAAK;YAAI,OACTC,EAAKC,KACDD,EAAKqB,SACLlB,QAAQC,OAAO,IAAIT,MAAM;UAAA,IAhCXI;YAyBpBsB,IAAIqC;UAAAA;YAAAA,IASoC,mBAAxBR,EAAgBpE,KAChC;cAAA,IAAMM,IAAM,IAAIC,IAAI6D,EAAgBpE;cAnChB;gBAAA;kBAAA6E;gBAAAC;kBAAA;oBAAA;oBAAA;sBAAA;sBAAA;sBAAA;wBAAAD;wBAAA;sBAAA;oBAAA;kBAAA;kBAAA;oBAAA;sBAAA;sBAAA;sBAAA;wBAAAE;wBAAA;sBAAA;sBAAA;sBAAAF;oBAAA;oBAAA;kBAAA;gBAAA;gBAAA;kBAAAG;gBAAA;kBAAA;oBAAA;sBAAAH;sBAAA;oBAAA;oBAAA;sBAAA;sBAAA;oBAAA;oBAAA;sBAAA;oBAAA;kBAAA;kBAAA;oBAAA;oBAAA;oBAAA;oBAAA;oBAAAA;kBAAA;kBAAAzB;gBAAA;gBAAA;kBAAA;oBAAA;oBAAA;oBAAAyB;oBAAA;oBAAA;kBAAA;kBAAAzB;gBAAA;cAAA,EAqCZ9C,EAAIL,UACL;gBAAA;cAAA,IACA;gBAAA;cAAA;gBACUe,6BAAMV,EAAImE,YAAYxD,KAAK;kBAAAC,OACtCA,EAAKC,KACDD,EAAKqB,SACLlB,QAAQC,OAAO,IAAIT,MAAM;gBAAA,IAJlBI;kBACbsB;gBAAA0C;cAAAA,IAOG;gBAAA;cAAA,GAAS;gBAAA,uBAEJlB,EAAKvC,QAAQ0D,aAAanF,QAAQqE,EAAgBpE,MAD1DuC;kBAAAA,IAAO8B,KAAKC,MAALa;gBAAAA;cAAAA,IAKJ;gBAAA;cAAA,IACA;gBAAA;cAAA;gBAEH,MAAUtE,UAAM;cAAA;YAAA;YAGf,IAAqC,mBAA1BuD,EAAgBzB,OAGhC,MAAU9B,UAAM;YAFhB0B,IAAO8B,KAAKC,MAAMF,EAAgBzB;UAAAA;QAcrC;MAAAyC;IAAAA;MAAAA;IAAAA;EAAAA;AAAAA;AAAAA;EAAAA;IAAAA;MAAAA;MAAAA;IAAAA;IAAAA;EAAAA;AAAAA;AEzFkBC;IAAAA;MAAAA,QAgBD1F;MAAAA,KAfV2F,MAA2C,IAAIC,YAWvDtB,oBACEvC,GACA8D;QACmC;UACnC,IAAMvB,IAAUT,EAAK8B,IAAIG,IAAI/D;UAE7B,IAAoB,MAAhB8D,EAAKnF,QACP,MAAM,IAAIQ,MAAM;UAGlB,OAIO2E,gBAJFvB,IAIEuB,EAAKE,OAAO,UAACC,GAAGtD;YAErB,OADAsD,EAAEtD,KAAK4B,EAAQ5B,MAAM,IACdsD;UAAAA,GACN,MANM;QAAA;UAAA;QAAA;MAAA;IAAA;IAAA,mBApBXC,gBAAIlE,GAAgBuC;MACbtE,KAAK2F,IAAIO,IAAInE,KAKlB/B,KAAK2F,IAAIM,IAAIlE,GAAboE,MAAyBnG,KAAK2F,IAAIG,IAAI/D,IAAYuC,MAJhDtE,KAAK2F,IAAIM,IAAIlE,GAAQuC;IAAAA;EAAAA;ECLN8B;IAAAA;MAAAA,KACnBT,MAAM,IAAIC;IAAAA;IAAAA;IAAAA,SAEVK,gBAAIlE,GAAgBC,GAAcG,GAAakE;MAC7CrG,KAAK2F,IAAIM,IAAOlE,UAAUC,IAA1B,MAAkCG,GAAOkE;IAAAA,KAGrCjG,UACJ2B,aACAC,GACAG,GACAL;MAAsB;QAAA,IAEhBO,IAAMrC,KAAK2F,IAAIG,IAAO/D,IAAUC,gBAAQG;QAE9C,uBAAKE,KACI;UAACkC,SAASxC;UAAQS,OAAO,CAAC;YAACL;YAAKQ,MAAMb;UAAAA;QAAAA;MAAAA;QAAAA;MAAAA;IAAAA;EAAAA;AAAAA","names":["DefaultIPFSResolver","defaultCreateUrl","createURL","this","cid","path","replace","resolve","uri","protocol","startsWith","substring","split","length","url","URL","hash","password","port","search","username","Error","hostname","pathname","fetch","then","resp","ok","text","Promise","reject","DefaultIssuerResolver","options","fallbackIssuer","domain","user","includes","_username$split","rel","webfingerResolver","jrd","link","_jrd$links","links","find","v","href","json","isJRDLink","isJRD","state","value","pact","observer","_Pact","prototype","onRejected","s","callback","onFulfilled","o","result","_settle","e","_this","window","_w","UAUTH_VERSION","COMMON","DefaultWebFingerResolver","webfingerKey","_this2","domainResolver","records","subject","resource","webfingerRecord","JSON","parse","host","URLSearchParams","toString","headers","Host","_fetch$then","n","r","t","p","_fetch$then2","ipfsResolver","_this$options$ipfsRes","_temp2","MemoryDomainResolver","map","Map","keys","get","reduce","a","set","has","_extends","MemoryWebFingerResolver","document"],"sources":["../src/DefaultIPFSResolver.ts","../src/DefaultIssuerResolver.ts","../src/JRD.ts","../src/DefaultWebFingerResolver.ts","../src/version.ts","../src/MemoryDomainResolver.ts","../src/MemoryWebFingerResolver.ts"],"sourcesContent":["import {IPFSResolver} from './types'\n\nexport default class DefaultIPFSResolver implements IPFSResolver {\n  static defaultCreateUrl(cid: string, path: string): string {\n    return `https://${cid}.ipns.dweb.link${path.replace(/^\\/?/, '/')}`\n  }\n\n  constructor(public createURL = DefaultIPFSResolver.defaultCreateUrl) {}\n\n  async resolve(uri: string): Promise<string> {\n    let cid: string\n    let path: string\n    let protocol: string\n\n    if (uri.startsWith('/ipfs/') || uri.startsWith('/ipns/')) {\n      protocol = uri.substring(1, 5)\n      cid = uri.substring(6).split('/')[0]\n      path = uri.substring(6 + cid.length)\n    } else {\n      const url = new URL(uri)\n\n      if (\n        url.hash !== '' ||\n        url.password !== '' ||\n        url.port !== '' ||\n        url.search !== '' ||\n        url.username !== ''\n      ) {\n        throw new Error('invalid ipfs uri')\n      }\n\n      protocol = url.protocol.substring(0, 4)\n      cid = url.hostname\n      path = url.pathname\n    }\n\n    if (protocol !== 'ipfs') {\n      throw new Error('only ipfs is supported, (not ipns)')\n    }\n\n    return fetch(this.createURL(cid, path)).then(resp =>\n      resp.ok ? resp.text() : Promise.reject(new Error('bad response')),\n    )\n  }\n}\n","import {IssuerResolver, IssuerResolverOptions} from './types'\n\nexport default class DefaultIssuerResolver implements IssuerResolver {\n  constructor(public options: IssuerResolverOptions) {}\n\n  async resolve(username: string, fallbackIssuer: string) {\n    let user = ''\n    let domain: string\n    if (username.includes('@')) {\n      ;[user, domain] = username.split('@', 1)\n    } else {\n      domain = username\n    }\n\n    const rel = 'http://openid.net/specs/connect/1.0/issuer'\n\n    const jrd = await this.options.webfingerResolver.resolve(\n      domain,\n      user,\n      rel,\n      fallbackIssuer,\n    )\n\n    const link = jrd.links?.find(v => v.rel === rel)\n    if (!link || !link.href) {\n      throw new Error('bad jrd')\n    }\n\n    const config = await fetch(\n      link.href + '/.well-known/openid-configuration',\n    ).then(resp =>\n      resp.ok\n        ? resp.json()\n        : Promise.reject(new Error('bad openid-configuration response')),\n    )\n\n    return config\n  }\n}\n","import {JRDDocument, JRDLink} from './types'\n\nexport function isJRDLink(json: any): json is JRDLink {\n  return true\n}\n\nexport function isJRD(json: any): json is JRDDocument {\n  return true\n}\n","import {isJRD} from './JRD'\nimport {JRDDocument, WebFingerRecord, WebFingerResolverOptions} from './types'\nimport {VERSION} from './version'\n\nif (typeof window !== 'undefined') {\n  const _w = window as any\n  _w.UAUTH_VERSION = _w.UAUTH_VERSION || {}\n  _w.UAUTH_VERSION.COMMON = VERSION\n}\n\nexport default class DefaultWebFingerResolver {\n  constructor(public options: WebFingerResolverOptions) {}\n\n  async resolve(\n    domain: string,\n    user: string,\n    rel: string,\n    fallbackIssuer: string,\n  ): Promise<JRDDocument> {\n    const webfingerKey = `webfinger.${user}.${rel}`\n\n    // console.log('domain:', domain)\n    // console.log('webfingerKey:', webfingerKey)\n\n    const records = await this.options.domainResolver.records(domain, [\n      webfingerKey,\n    ])\n\n    const resource = user ? `acct:${user}@${domain}` : `${domain}`\n\n    // console.log('record value:', records[webfingerKey])\n\n    if (!records[webfingerKey]) {\n      return {subject: resource, links: [{rel, href: fallbackIssuer}]}\n    }\n\n    const webfingerRecord: WebFingerRecord = JSON.parse(records[webfingerKey])\n\n    // console.log('webfingerRecord:', webfingerRecord)\n\n    let json\n    if (typeof webfingerRecord.host === 'string') {\n      json = await fetch(\n        '/.well-known/webfinger?' +\n          new URLSearchParams({resource, rel}).toString(),\n        {headers: {Host: webfingerRecord.host}},\n      ).then(resp =>\n        resp.ok\n          ? resp.json()\n          : Promise.reject(new Error('bad webfinger response')),\n      )\n    } else if (typeof webfingerRecord.uri === 'string') {\n      const url = new URL(webfingerRecord.uri)\n\n      switch (url.protocol) {\n        case 'http:':\n        case 'https:': {\n          json = await fetch(url.toString()).then(resp =>\n            resp.ok\n              ? resp.json()\n              : Promise.reject(new Error('bad webfinger response')),\n          )\n          break\n        }\n        case 'ipfs:': {\n          json = JSON.parse(\n            await this.options.ipfsResolver.resolve(webfingerRecord.uri),\n          )\n          break\n        }\n        case 'ipns:':\n        case 'swarm:':\n        default: {\n          throw new Error('uri scheme not supported')\n        }\n      }\n    } else if (typeof webfingerRecord.value === 'string') {\n      json = JSON.parse(webfingerRecord.value)\n    } else {\n      throw new Error('bad webfinger record')\n    }\n\n    if (!isJRD(json)) {\n      throw new Error('resolved document not jrd')\n    }\n\n    if (json.subject !== resource) {\n      throw new Error('resource invalid')\n    }\n\n    return json\n  }\n}\n","export const VERSION = \"2.3.0\";\n","import {DomainResolver} from './types'\n\nexport default class MemoryDomainResolver implements DomainResolver {\n  private map: Map<string, Record<string, string>> = new Map()\n\n  set(domain: string, records: Record<string, string>): void {\n    if (!this.map.has(domain)) {\n      this.map.set(domain, records)\n      return\n    }\n\n    this.map.set(domain, {...this.map.get(domain), ...records})\n  }\n\n  records = async (\n    domain: string,\n    keys: string[],\n  ): Promise<Record<string, string>> => {\n    const records = this.map.get(domain)\n\n    if (keys.length === 0) {\n      throw new Error('no keys')\n    }\n\n    if (!records) {\n      return {}\n    }\n\n    return keys.reduce((a, v) => {\n      a[v] = records[v] || ''\n      return a\n    }, {} as Record<string, string>)\n  }\n}\n","import {JRDDocument, WebFingerResolver} from './types'\n\nexport default class MemoryWebFingerResolver implements WebFingerResolver {\n  map = new Map<string, JRDDocument>()\n\n  set(domain: string, user: string, rel: string, document: JRDDocument): void {\n    this.map.set(`${domain}.${user}.${rel}`, document)\n  }\n\n  async resolve(\n    domain: string,\n    user: string,\n    rel: string,\n    fallbackIssuer: string,\n  ): Promise<JRDDocument> {\n    const jrd = this.map.get(`${domain}.${user}.${rel}`)\n\n    if (!jrd) {\n      return {subject: domain, links: [{rel, href: fallbackIssuer}]}\n    }\n\n    return jrd\n  }\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}