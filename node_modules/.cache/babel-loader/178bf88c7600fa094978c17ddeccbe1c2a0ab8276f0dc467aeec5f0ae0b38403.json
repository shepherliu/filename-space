{"ast":null,"code":"\"use strict\";\n\n/**\n * All functionality below came from here https://github.com/Zilliqa/Zilliqa-JavaScript-Library/tree/dev/packages/zilliqa-js-crypto/src\n */\nrequire(\"core-js/modules/es.array.push.js\");\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.fromBech32Address = exports.toBech32Address = exports.toChecksumAddress = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nvar enc_hex_1 = __importDefault(require(\"crypto-js/enc-hex\"));\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n// HRP is the human-readable part of zilliqa bech32 addresses\nvar HRP = 'zil';\nvar tHRP = 'tzil';\nfunction isByteString(str, len) {\n  return !!str.replace('0x', '').match(\"^[0-9a-fA-F]{\".concat(len, \"}$\"));\n}\nfunction isAddress(address) {\n  return isByteString(address, 40);\n}\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\nfunction convertBits(data, fromWidth, toWidth, pad) {\n  if (pad === void 0) {\n    pad = true;\n  }\n  var acc = 0;\n  var bits = 0;\n  var ret = [];\n  var maxv = (1 << toWidth) - 1;\n  // tslint:disable-next-line\n  for (var p = 0; p < data.length; ++p) {\n    var value = data[p];\n    if (value < 0 || value >> fromWidth !== 0) {\n      return null;\n    }\n    acc = acc << fromWidth | value;\n    bits += fromWidth;\n    while (bits >= toWidth) {\n      bits -= toWidth;\n      ret.push(acc >> bits & maxv);\n    }\n  }\n  if (pad) {\n    if (bits > 0) {\n      ret.push(acc << toWidth - bits & maxv);\n    }\n  } else if (bits >= fromWidth || acc << toWidth - bits & maxv) {\n    return null;\n  }\n  return Buffer.from(ret);\n}\nfunction hrpExpand(hrp) {\n  var ret = [];\n  var p;\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) >> 5);\n  }\n  ret.push(0);\n  for (p = 0; p < hrp.length; ++p) {\n    ret.push(hrp.charCodeAt(p) & 31);\n  }\n  return Buffer.from(ret);\n}\nfunction polymod(values) {\n  var chk = 1;\n  // tslint:disable-next-line\n  for (var p = 0; p < values.length; ++p) {\n    var top_1 = chk >> 25;\n    chk = (chk & 0x1ffffff) << 5 ^ values[p];\n    for (var i = 0; i < 5; ++i) {\n      if (top_1 >> i & 1) {\n        chk ^= GENERATOR[i];\n      }\n    }\n  }\n  return chk;\n}\nfunction createChecksum(hrp, data) {\n  var values = Buffer.concat([Buffer.from(hrpExpand(hrp)), data, Buffer.from([0, 0, 0, 0, 0, 0])]);\n  // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n  var mod = polymod(values) ^ 1;\n  var ret = [];\n  for (var p = 0; p < 6; ++p) {\n    ret.push(mod >> 5 * (5 - p) & 31);\n  }\n  return Buffer.from(ret);\n}\nfunction verifyChecksum(hrp, data) {\n  return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\nfunction encode(hrp, data) {\n  var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n  var ret = hrp + '1';\n  // tslint:disable-next-line\n  for (var p = 0; p < combined.length; ++p) {\n    ret += CHARSET.charAt(combined[p]);\n  }\n  return ret;\n}\nfunction decode(bechString) {\n  var p;\n  var hasLower = false;\n  var hasUpper = false;\n  for (p = 0; p < bechString.length; ++p) {\n    if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n      return null;\n    }\n    if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n      hasLower = true;\n    }\n    if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n      hasUpper = true;\n    }\n  }\n  if (hasLower && hasUpper) {\n    return null;\n  }\n  bechString = bechString.toLowerCase();\n  var pos = bechString.lastIndexOf('1');\n  if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n    return null;\n  }\n  var hrp = bechString.substring(0, pos);\n  var data = [];\n  for (p = pos + 1; p < bechString.length; ++p) {\n    var d = CHARSET.indexOf(bechString.charAt(p));\n    if (d === -1) {\n      return null;\n    }\n    data.push(d);\n  }\n  if (!verifyChecksum(hrp, Buffer.from(data))) {\n    return null;\n  }\n  return {\n    hrp: hrp,\n    data: Buffer.from(data.slice(0, data.length - 6))\n  };\n}\n/**\n * toChecksumAddress\n *\n * takes hex-encoded string and returns the corresponding address\n * @param {string} address\n * @returns {string}\n */\nvar toChecksumAddress = function (address) {\n  if (!isAddress(address)) {\n    throw new Error(\"\".concat(address, \" is not a valid base 16 address\"));\n  }\n  address = address.toLowerCase().replace('0x', '');\n  var hash = enc_hex_1.default.stringify((0, sha256_1.default)(enc_hex_1.default.parse(address)));\n  var v = new bn_js_1.default(hash, 'hex', 'be');\n  var ret = '0x';\n  for (var i = 0; i < address.length; i++) {\n    if ('0123456789'.indexOf(address[i]) !== -1) {\n      ret += address[i];\n    } else {\n      ret += v.and(new bn_js_1.default(2).pow(new bn_js_1.default(255 - 6 * i))).gte(new bn_js_1.default(1)) ? address[i].toUpperCase() : address[i].toLowerCase();\n    }\n  }\n  return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * toBech32Address\n *\n * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\n * address.\n *\n * The expected format is zil1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n * @param {string} address 20 byte canonical address\n * @param {boolean} testnet\n * @returns {string} 38 char bech32 encoded zilliqa address\n */\nfunction toBech32Address(address, testnet) {\n  if (testnet === void 0) {\n    testnet = false;\n  }\n  if (!isAddress(address)) {\n    throw new Error('Invalid address format.');\n  }\n  var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n  if (addrBz === null) {\n    throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n  }\n  return encode(testnet ? tHRP : HRP, addrBz);\n}\nexports.toBech32Address = toBech32Address;\n/**\n * fromBech32Address\n * @param {string} address - a valid Zilliqa bech32 address\n * @param {boolean} testnet\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\nfunction fromBech32Address(address, testnet) {\n  if (testnet === void 0) {\n    testnet = false;\n  }\n  var res = decode(address);\n  if (res === null) {\n    throw new Error('Invalid bech32 address');\n  }\n  var hrp = res.hrp,\n    data = res.data;\n  var shouldBe = testnet ? tHRP : HRP;\n  if (hrp !== shouldBe) {\n    throw new Error(\"Expected hrp to be \".concat(shouldBe, \" but got \").concat(hrp));\n  }\n  var buf = convertBits(data, 5, 8, false);\n  if (buf === null) {\n    throw new Error('Could not convert buffer to bytes');\n  }\n  return (0, exports.toChecksumAddress)(buf.toString('hex'));\n}\nexports.fromBech32Address = fromBech32Address;","map":{"version":3,"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","fromBech32Address","toBech32Address","toChecksumAddress","bn_js_1","require","sha256_1","enc_hex_1","CHARSET","GENERATOR","HRP","tHRP","isByteString","str","len","replace","match","concat","isAddress","address","convertBits","data","fromWidth","toWidth","pad","acc","bits","ret","maxv","p","length","push","Buffer","from","hrpExpand","hrp","charCodeAt","polymod","values","chk","top_1","i","createChecksum","verifyChecksum","encode","combined","charAt","decode","bechString","hasLower","hasUpper","toLowerCase","pos","lastIndexOf","substring","d","indexOf","slice","Error","hash","default","stringify","parse","v","and","pow","gte","toUpperCase","testnet","addrBz","res","shouldBe","buf","toString"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/@unstoppabledomains/resolution/build/utils/znsUtils.js"],"sourcesContent":["\"use strict\";\n/**\n * All functionality below came from here https://github.com/Zilliqa/Zilliqa-JavaScript-Library/tree/dev/packages/zilliqa-js-crypto/src\n */\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromBech32Address = exports.toBech32Address = exports.toChecksumAddress = void 0;\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar sha256_1 = __importDefault(require(\"crypto-js/sha256\"));\nvar enc_hex_1 = __importDefault(require(\"crypto-js/enc-hex\"));\nvar CHARSET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nvar GENERATOR = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n// HRP is the human-readable part of zilliqa bech32 addresses\nvar HRP = 'zil';\nvar tHRP = 'tzil';\nfunction isByteString(str, len) {\n    return !!str.replace('0x', '').match(\"^[0-9a-fA-F]{\".concat(len, \"}$\"));\n}\nfunction isAddress(address) {\n    return isByteString(address, 40);\n}\n/**\n * convertBits\n *\n * groups buffers of a certain width to buffers of the desired width.\n *\n * For example, converts byte buffers to buffers of maximum 5 bit numbers,\n * padding those numbers as necessary. Necessary for encoding Ethereum-style\n * addresses as bech32 ones.\n * @param {Buffer} data\n * @param {number} fromWidth\n * @param {number} toWidth\n * @param {boolean} pad\n * @returns {Buffer|null}\n */\nfunction convertBits(data, fromWidth, toWidth, pad) {\n    if (pad === void 0) { pad = true; }\n    var acc = 0;\n    var bits = 0;\n    var ret = [];\n    var maxv = (1 << toWidth) - 1;\n    // tslint:disable-next-line\n    for (var p = 0; p < data.length; ++p) {\n        var value = data[p];\n        if (value < 0 || value >> fromWidth !== 0) {\n            return null;\n        }\n        acc = (acc << fromWidth) | value;\n        bits += fromWidth;\n        while (bits >= toWidth) {\n            bits -= toWidth;\n            ret.push((acc >> bits) & maxv);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            ret.push((acc << (toWidth - bits)) & maxv);\n        }\n    }\n    else if (bits >= fromWidth || (acc << (toWidth - bits)) & maxv) {\n        return null;\n    }\n    return Buffer.from(ret);\n}\nfunction hrpExpand(hrp) {\n    var ret = [];\n    var p;\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) >> 5);\n    }\n    ret.push(0);\n    for (p = 0; p < hrp.length; ++p) {\n        ret.push(hrp.charCodeAt(p) & 31);\n    }\n    return Buffer.from(ret);\n}\nfunction polymod(values) {\n    var chk = 1;\n    // tslint:disable-next-line\n    for (var p = 0; p < values.length; ++p) {\n        var top_1 = chk >> 25;\n        chk = ((chk & 0x1ffffff) << 5) ^ values[p];\n        for (var i = 0; i < 5; ++i) {\n            if ((top_1 >> i) & 1) {\n                chk ^= GENERATOR[i];\n            }\n        }\n    }\n    return chk;\n}\nfunction createChecksum(hrp, data) {\n    var values = Buffer.concat([\n        Buffer.from(hrpExpand(hrp)),\n        data,\n        Buffer.from([0, 0, 0, 0, 0, 0]),\n    ]);\n    // var values = hrpExpand(hrp).concat(data).concat([0, 0, 0, 0, 0, 0]);\n    var mod = polymod(values) ^ 1;\n    var ret = [];\n    for (var p = 0; p < 6; ++p) {\n        ret.push((mod >> (5 * (5 - p))) & 31);\n    }\n    return Buffer.from(ret);\n}\nfunction verifyChecksum(hrp, data) {\n    return polymod(Buffer.concat([hrpExpand(hrp), data])) === 1;\n}\nfunction encode(hrp, data) {\n    var combined = Buffer.concat([data, createChecksum(hrp, data)]);\n    var ret = hrp + '1';\n    // tslint:disable-next-line\n    for (var p = 0; p < combined.length; ++p) {\n        ret += CHARSET.charAt(combined[p]);\n    }\n    return ret;\n}\nfunction decode(bechString) {\n    var p;\n    var hasLower = false;\n    var hasUpper = false;\n    for (p = 0; p < bechString.length; ++p) {\n        if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {\n            return null;\n        }\n        if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {\n            hasLower = true;\n        }\n        if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {\n            hasUpper = true;\n        }\n    }\n    if (hasLower && hasUpper) {\n        return null;\n    }\n    bechString = bechString.toLowerCase();\n    var pos = bechString.lastIndexOf('1');\n    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {\n        return null;\n    }\n    var hrp = bechString.substring(0, pos);\n    var data = [];\n    for (p = pos + 1; p < bechString.length; ++p) {\n        var d = CHARSET.indexOf(bechString.charAt(p));\n        if (d === -1) {\n            return null;\n        }\n        data.push(d);\n    }\n    if (!verifyChecksum(hrp, Buffer.from(data))) {\n        return null;\n    }\n    return { hrp: hrp, data: Buffer.from(data.slice(0, data.length - 6)) };\n}\n/**\n * toChecksumAddress\n *\n * takes hex-encoded string and returns the corresponding address\n * @param {string} address\n * @returns {string}\n */\nvar toChecksumAddress = function (address) {\n    if (!isAddress(address)) {\n        throw new Error(\"\".concat(address, \" is not a valid base 16 address\"));\n    }\n    address = address.toLowerCase().replace('0x', '');\n    var hash = enc_hex_1.default.stringify((0, sha256_1.default)(enc_hex_1.default.parse(address)));\n    var v = new bn_js_1.default(hash, 'hex', 'be');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if ('0123456789'.indexOf(address[i]) !== -1) {\n            ret += address[i];\n        }\n        else {\n            ret += v.and(new bn_js_1.default(2).pow(new bn_js_1.default(255 - 6 * i))).gte(new bn_js_1.default(1))\n                ? address[i].toUpperCase()\n                : address[i].toLowerCase();\n        }\n    }\n    return ret;\n};\nexports.toChecksumAddress = toChecksumAddress;\n/**\n * toBech32Address\n *\n * Encodes a canonical 20-byte Ethereum-style address as a bech32 zilliqa\n * address.\n *\n * The expected format is zil1<address><checksum> where address and checksum\n * are the result of bech32 encoding a Buffer containing the address bytes.\n * @param {string} address 20 byte canonical address\n * @param {boolean} testnet\n * @returns {string} 38 char bech32 encoded zilliqa address\n */\nfunction toBech32Address(address, testnet) {\n    if (testnet === void 0) { testnet = false; }\n    if (!isAddress(address)) {\n        throw new Error('Invalid address format.');\n    }\n    var addrBz = convertBits(Buffer.from(address.replace('0x', ''), 'hex'), 8, 5);\n    if (addrBz === null) {\n        throw new Error('Could not convert byte Buffer to 5-bit Buffer');\n    }\n    return encode(testnet ? tHRP : HRP, addrBz);\n}\nexports.toBech32Address = toBech32Address;\n/**\n * fromBech32Address\n * @param {string} address - a valid Zilliqa bech32 address\n * @param {boolean} testnet\n * @returns {string} a canonical 20-byte Ethereum-style address\n */\nfunction fromBech32Address(address, testnet) {\n    if (testnet === void 0) { testnet = false; }\n    var res = decode(address);\n    if (res === null) {\n        throw new Error('Invalid bech32 address');\n    }\n    var hrp = res.hrp, data = res.data;\n    var shouldBe = testnet ? tHRP : HRP;\n    if (hrp !== shouldBe) {\n        throw new Error(\"Expected hrp to be \".concat(shouldBe, \" but got \").concat(hrp));\n    }\n    var buf = convertBits(data, 5, 8, false);\n    if (buf === null) {\n        throw new Error('Could not convert buffer to bytes');\n    }\n    return (0, exports.toChecksumAddress)(buf.toString('hex'));\n}\nexports.fromBech32Address = fromBech32Address;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}