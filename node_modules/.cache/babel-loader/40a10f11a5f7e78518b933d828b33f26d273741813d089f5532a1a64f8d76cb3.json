{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nasync function* _batch(size, iterable) {\n  let dataBatch = [];\n  for await (const data of iterable) {\n    dataBatch.push(data);\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\nfunction* _syncBatch(size, iterable) {\n  let dataBatch = [];\n  for (const data of iterable) {\n    dataBatch.push(data);\n    if (dataBatch.length === size) {\n      yield dataBatch;\n      dataBatch = [];\n    }\n  }\n  if (dataBatch.length > 0) {\n    yield dataBatch;\n  }\n}\nfunction batch(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batch(size, curriedIterable);\n  }\n  if (iterable[Symbol.asyncIterator]) {\n    return _batch(size, iterable);\n  }\n  return _syncBatch(size, iterable);\n}\nconst TIMEOUT = Symbol('TIMEOUT');\nconst createTimer = duration => {\n  let timeoutId;\n  return [new Promise(resolve => {\n    timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n  }), () => {\n    clearTimeout(timeoutId);\n  }];\n};\n// Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\nasync function* _batchWithTimeout(size, timeout, iterable) {\n  const iterator = iterable[Symbol.asyncIterator]();\n  let pendingData;\n  let batchData = [];\n  let timer;\n  let clearTimer;\n  const startTimer = () => {\n    deleteTimer();\n    [timer, clearTimer] = createTimer(timeout);\n  };\n  const deleteTimer = () => {\n    if (clearTimer) {\n      clearTimer();\n    }\n    timer = undefined;\n  };\n  pendingData = iterator.next();\n  while (true) {\n    const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n    if (res === TIMEOUT || res.done) {\n      // Flush early (before we reach the batch size)\n      if (batchData.length) {\n        yield batchData;\n        batchData = [];\n      }\n      deleteTimer();\n      // And exit appropriately\n      if (res !== TIMEOUT) {\n        // done\n        break;\n      }\n      continue;\n    }\n    // Fetch next item early doors (before we potentially yield)\n    pendingData = iterator.next();\n    // Then handle the value\n    batchData.push(res.value);\n    if (batchData.length === 1) {\n      // Start timer once we have at least 1 item ready to go\n      startTimer();\n    }\n    if (batchData.length === size) {\n      yield batchData;\n      batchData = [];\n      deleteTimer();\n      continue;\n    }\n  }\n}\nfunction batchWithTimeout(size, timeout, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n  }\n  if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n    return _batchWithTimeout(size, timeout, iterable);\n  }\n  // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n  return batch(size, iterable);\n}\nfunction getIterator(iterable) {\n  if (typeof iterable.next === 'function') {\n    return iterable;\n  }\n  if (typeof iterable[Symbol.iterator] === 'function') {\n    return iterable[Symbol.iterator]();\n  }\n  if (typeof iterable[Symbol.asyncIterator] === 'function') {\n    return iterable[Symbol.asyncIterator]();\n  }\n  throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\nfunction defer() {\n  let reject;\n  let resolve;\n  const promise = new Promise((resolveFunc, rejectFunc) => {\n    resolve = resolveFunc;\n    reject = rejectFunc;\n  });\n  return {\n    promise,\n    reject,\n    resolve\n  };\n}\nfunction _buffer(size, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let reading = false;\n  let ended = false;\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const readDeferred = readQueue.shift();\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n      if (error) {\n        readDeferred.reject(error);\n      } else {\n        readDeferred.resolve({\n          done: false,\n          value\n        });\n      }\n    }\n    while (readQueue.length > 0 && ended) {\n      const {\n        resolve\n      } = readQueue.shift();\n      resolve({\n        done: true,\n        value: undefined\n      });\n    }\n  }\n  async function fillQueue() {\n    if (ended) {\n      return;\n    }\n    if (reading) {\n      return;\n    }\n    if (resultQueue.length >= size) {\n      return;\n    }\n    reading = true;\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n      if (done) {\n        ended = true;\n      } else {\n        resultQueue.push({\n          value\n        });\n      }\n    } catch (error) {\n      ended = true;\n      resultQueue.push({\n        error\n      });\n    }\n    fulfillReadQueue();\n    reading = false;\n    fillQueue();\n  }\n  async function next() {\n    if (resultQueue.length > 0) {\n      const {\n        error,\n        value\n      } = resultQueue.shift();\n      if (error) {\n        throw error;\n      }\n      fillQueue();\n      return {\n        done: false,\n        value\n      };\n    }\n    if (ended) {\n      return {\n        done: true,\n        value: undefined\n      }; // stupid ts\n    }\n\n    const deferred = defer();\n    readQueue.push(deferred);\n    fillQueue();\n    return deferred.promise;\n  }\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n  const valueQueue = [];\n  let e;\n  try {\n    for (const value of iterable) {\n      valueQueue.push(value);\n      if (valueQueue.length <= size) {\n        continue;\n      }\n      yield valueQueue.shift();\n    }\n  } catch (error) {\n    e = error;\n  }\n  for (const value of valueQueue) {\n    yield value;\n  }\n  if (e) {\n    throw e;\n  }\n}\nfunction buffer(size, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => buffer(size, curriedIterable);\n  }\n  if (size === 0) {\n    return iterable;\n  }\n  if (iterable[Symbol.asyncIterator]) {\n    return _buffer(size, iterable);\n  }\n  return syncBuffer(size, iterable);\n}\nasync function _collect(iterable) {\n  const values = [];\n  for await (const value of iterable) {\n    values.push(value);\n  }\n  return values;\n}\nfunction collect(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _collect(iterable);\n  }\n  return Array.from(iterable);\n}\nasync function* _concat(iterables) {\n  for await (const iterable of iterables) {\n    yield* iterable;\n  }\n}\nfunction* _syncConcat(iterables) {\n  for (const iterable of iterables) {\n    yield* iterable;\n  }\n}\nfunction concat(...iterables) {\n  const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n  if (hasAnyAsync) {\n    return _concat(iterables);\n  } else {\n    return _syncConcat(iterables);\n  }\n}\nasync function _consume(iterable) {\n  for await (const val of iterable) {\n    // do nothing\n  }\n}\nfunction consume(iterable) {\n  if (iterable[Symbol.asyncIterator]) {\n    return _consume(iterable);\n  }\n  for (const val of iterable) {\n    // do nothing\n  }\n}\nasync function* _filter(filterFunc, iterable) {\n  for await (const data of iterable) {\n    if (await filterFunc(data)) {\n      yield data;\n    }\n  }\n}\nfunction filter(filterFunc, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _filter(filterFunc, curriedIterable);\n  }\n  return _filter(filterFunc, iterable);\n}\nasync function* flatten(iterable) {\n  for await (const maybeItr of iterable) {\n    if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n      yield* flatten(maybeItr);\n    } else {\n      yield maybeItr;\n    }\n  }\n}\nasync function* _map(func, iterable) {\n  for await (const val of iterable) {\n    yield await func(val);\n  }\n}\nfunction map(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _map(func, curriedIterable);\n  }\n  return _map(func, iterable);\n}\nfunction flatMap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => flatMap(func, curriedIterable);\n  }\n  return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\nfunction _flatTransform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n    if (reading) {\n      return;\n    }\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n    reading = true;\n    inflightCount++;\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n    reading = false;\n    fillQueue();\n  }\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      if (value && value[Symbol.asyncIterator]) {\n        for await (const asyncVal of value) {\n          resultQueue.push(asyncVal);\n        }\n      } else {\n        resultQueue.push(value);\n      }\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => flatTransform(concurrency, func, curriedIterable);\n  }\n  return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', () => {\n      resolve();\n    });\n  });\n}\nasync function* _fromStream(stream) {\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield data;\n      continue;\n    }\n    if (stream._readableState.ended) {\n      break;\n    }\n    await onceReadable(stream);\n  }\n}\nfunction fromStream(stream) {\n  if (typeof stream[Symbol.asyncIterator] === 'function') {\n    return stream;\n  }\n  return _fromStream(stream);\n}\nasync function* merge(...iterables) {\n  const sources = new Set(iterables.map(getIterator));\n  while (sources.size > 0) {\n    for (const iterator of sources) {\n      const nextVal = await iterator.next();\n      if (nextVal.done) {\n        sources.delete(iterator);\n      } else {\n        yield nextVal.value;\n      }\n    }\n  }\n}\nfunction pipeline(firstFn, ...fns) {\n  let previousFn = firstFn();\n  for (const func of fns) {\n    previousFn = func(previousFn);\n  }\n  return previousFn;\n}\nasync function* _parallelMap(concurrency, func, iterable) {\n  let transformError = null;\n  const wrapFunc = value => ({\n    value: func(value)\n  });\n  const stopOnError = async function* (source) {\n    for await (const value of source) {\n      if (transformError) {\n        return;\n      }\n      yield value;\n    }\n  };\n  const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n  const itr = getIterator(output);\n  while (true) {\n    const {\n      value,\n      done\n    } = await itr.next();\n    if (done) {\n      break;\n    }\n    try {\n      const val = await value.value;\n      if (!transformError) {\n        yield val;\n      }\n    } catch (error) {\n      transformError = error;\n    }\n  }\n  if (transformError) {\n    throw transformError;\n  }\n}\nfunction parallelMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n  }\n  if (concurrency === 1) {\n    return map(func, iterable);\n  }\n  return _parallelMap(concurrency, func, iterable);\n}\nfunction parallelFlatMap(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => parallelFlatMap(concurrency, func, curriedIterable);\n  }\n  return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\nasync function* parallelMerge(...iterables) {\n  const inputs = iterables.map(getIterator);\n  const concurrentWork = new Set();\n  const values = new Map();\n  let lastError = null;\n  let errCb = null;\n  let valueCb = null;\n  const notifyError = err => {\n    lastError = err;\n    if (errCb) {\n      errCb(err);\n    }\n  };\n  const notifyDone = value => {\n    if (valueCb) {\n      valueCb(value);\n    }\n  };\n  const waitForQueue = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      reject(lastError);\n    }\n    if (values.size > 0) {\n      return resolve();\n    }\n    valueCb = resolve;\n    errCb = reject;\n  });\n  const queueNext = input => {\n    const nextVal = Promise.resolve(input.next()).then(async ({\n      done,\n      value\n    }) => {\n      if (!done) {\n        values.set(input, value);\n      }\n      concurrentWork.delete(nextVal);\n    });\n    concurrentWork.add(nextVal);\n    nextVal.then(notifyDone, notifyError);\n  };\n  for (const input of inputs) {\n    queueNext(input);\n  }\n  while (true) {\n    // We technically don't have to check `values.size` as the for loop should have emptied it\n    // However I haven't yet found specs verifying that behavior, only tests\n    // the guard in waitForQueue() checking for values is in place for the same reason\n    if (concurrentWork.size === 0 && values.size === 0) {\n      return;\n    }\n    await waitForQueue();\n    for (const [input, value] of values) {\n      values.delete(input);\n      yield value;\n      queueNext(input);\n    }\n  }\n}\nasync function _reduce(func, start, iterable) {\n  let value = start;\n  for await (const nextItem of iterable) {\n    value = await func(value, nextItem);\n  }\n  return value;\n}\nfunction reduce(func, start, iterable) {\n  if (start === undefined) {\n    return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => reduce(func, start, curriedIterable);\n  }\n  return _reduce(func, start, iterable);\n}\nasync function* _take(count, iterable) {\n  let taken = 0;\n  for await (const val of iterable) {\n    yield await val;\n    taken++;\n    if (taken >= count) {\n      break;\n    }\n  }\n}\nfunction* _syncTake(count, iterable) {\n  let taken = 0;\n  for (const val of iterable) {\n    yield val;\n    taken++;\n    if (taken >= count) {\n      break;\n    }\n  }\n}\nfunction take(count, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => take(count, curriedIterable);\n  }\n  if (iterable[Symbol.asyncIterator]) {\n    return _take(count, iterable);\n  }\n  return _syncTake(count, iterable);\n}\nasync function* _asyncTap(func, iterable) {\n  for await (const val of iterable) {\n    await func(val);\n    yield val;\n  }\n}\nfunction tap(func, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _asyncTap(func, curriedIterable);\n  }\n  return _asyncTap(func, iterable);\n}\nconst sleep = ms => new Promise(resolve => setTimeout(resolve, ms));\nfunction _throttle(limit, interval, iterable) {\n  if (!Number.isFinite(limit)) {\n    throw new TypeError('Expected `limit` to be a finite number');\n  }\n  if (limit <= 0) {\n    throw new TypeError('Expected `limit` to be greater than 0');\n  }\n  if (!Number.isFinite(interval)) {\n    throw new TypeError('Expected `interval` to be a finite number');\n  }\n  return async function* __throttle() {\n    let sent = 0;\n    let time;\n    for await (const val of iterable) {\n      if (sent < limit) {\n        if (typeof time === 'undefined') {\n          time = Date.now();\n        }\n        sent++;\n        yield val;\n        continue;\n      }\n      // Only wait if the interval hasn't already passed while we were\n      // yielding the previous values.\n      const elapsedMs = Date.now() - time;\n      const waitFor = interval - elapsedMs;\n      if (waitFor > 0) {\n        await sleep(waitFor);\n      }\n      time = Date.now();\n      sent = 1;\n      yield val;\n    }\n  }();\n}\nfunction throttle(limit, interval, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _throttle(limit, interval, curriedIterable);\n  }\n  return _throttle(limit, interval, iterable);\n}\nfunction addTime(a, b) {\n  let seconds = a[0] + b[0];\n  let nanoseconds = a[1] + b[1];\n  if (nanoseconds >= 1000000000) {\n    const remainder = nanoseconds % 1000000000;\n    seconds += (nanoseconds - remainder) / 1000000000;\n    nanoseconds = remainder;\n  }\n  return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n  const itr = iterable[Symbol.asyncIterator]();\n  let total = [0, 0];\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = await itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n      return value;\n    }\n    yield value;\n  }\n}\nfunction* _syncTime(config, iterable) {\n  const itr = iterable[Symbol.iterator]();\n  let total = [0, 0];\n  while (true) {\n    const start = process.hrtime();\n    const {\n      value,\n      done\n    } = itr.next();\n    const delta = process.hrtime(start);\n    total = addTime(total, delta);\n    if (config.progress) {\n      config.progress(delta, total);\n    }\n    if (done) {\n      if (config.total) {\n        config.total(total);\n      }\n      return value;\n    }\n    yield value;\n  }\n}\nfunction time(config = {}, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => time(config, curriedIterable);\n  }\n  if (iterable[Symbol.asyncIterator] !== undefined) {\n    return _asyncTime(config, iterable);\n  } else {\n    return _syncTime(config, iterable);\n  }\n}\nfunction _transform(concurrency, func, iterable) {\n  const iterator = getIterator(iterable);\n  const resultQueue = [];\n  const readQueue = [];\n  let ended = false;\n  let reading = false;\n  let inflightCount = 0;\n  let lastError = null;\n  function fulfillReadQueue() {\n    while (readQueue.length > 0 && resultQueue.length > 0) {\n      const {\n        resolve\n      } = readQueue.shift();\n      const value = resultQueue.shift();\n      resolve({\n        done: false,\n        value\n      });\n    }\n    while (readQueue.length > 0 && inflightCount === 0 && ended) {\n      const {\n        resolve,\n        reject\n      } = readQueue.shift();\n      if (lastError) {\n        reject(lastError);\n        lastError = null;\n      } else {\n        resolve({\n          done: true,\n          value: undefined\n        });\n      }\n    }\n  }\n  async function fillQueue() {\n    if (ended) {\n      fulfillReadQueue();\n      return;\n    }\n    if (reading) {\n      return;\n    }\n    if (inflightCount + resultQueue.length >= concurrency) {\n      return;\n    }\n    reading = true;\n    inflightCount++;\n    try {\n      const {\n        done,\n        value\n      } = await iterator.next();\n      if (done) {\n        ended = true;\n        inflightCount--;\n        fulfillReadQueue();\n      } else {\n        mapAndQueue(value);\n      }\n    } catch (error) {\n      ended = true;\n      inflightCount--;\n      lastError = error;\n      fulfillReadQueue();\n    }\n    reading = false;\n    fillQueue();\n  }\n  async function mapAndQueue(itrValue) {\n    try {\n      const value = await func(itrValue);\n      resultQueue.push(value);\n    } catch (error) {\n      ended = true;\n      lastError = error;\n    }\n    inflightCount--;\n    fulfillReadQueue();\n    fillQueue();\n  }\n  async function next() {\n    if (resultQueue.length === 0) {\n      const deferred = defer();\n      readQueue.push(deferred);\n      fillQueue();\n      return deferred.promise;\n    }\n    const value = resultQueue.shift();\n    fillQueue();\n    return {\n      done: false,\n      value\n    };\n  }\n  const asyncIterableIterator = {\n    next,\n    [Symbol.asyncIterator]: () => asyncIterableIterator\n  };\n  return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n  if (func === undefined) {\n    return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);\n  }\n  if (iterable === undefined) {\n    return curriedIterable => transform(concurrency, func, curriedIterable);\n  }\n  return _transform(concurrency, func, iterable);\n}\nasync function _writeToStream(stream, iterable) {\n  let lastError = null;\n  let errCb = null;\n  let drainCb = null;\n  const notifyError = err => {\n    lastError = err;\n    if (errCb) {\n      errCb(err);\n    }\n  };\n  const notifyDrain = () => {\n    if (drainCb) {\n      drainCb();\n    }\n  };\n  const cleanup = () => {\n    stream.removeListener('error', notifyError);\n    stream.removeListener('drain', notifyDrain);\n  };\n  stream.once('error', notifyError);\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    if (lastError) {\n      return reject(lastError);\n    }\n    stream.once('drain', notifyDrain);\n    drainCb = resolve;\n    errCb = reject;\n  });\n  for await (const value of iterable) {\n    if (stream.write(value) === false) {\n      await waitForDrain();\n    }\n    if (lastError) {\n      break;\n    }\n  }\n  cleanup();\n  if (lastError) {\n    throw lastError;\n  }\n}\nfunction writeToStream(stream, iterable) {\n  if (iterable === undefined) {\n    return curriedIterable => _writeToStream(stream, curriedIterable);\n  }\n  return _writeToStream(stream, iterable);\n}\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, throttle, time, transform, writeToStream };","map":{"version":3,"names":["_batch","size","iterable","dataBatch","data","push","length","_syncBatch","batch","undefined","curriedIterable","Symbol","asyncIterator","TIMEOUT","createTimer","duration","timeoutId","Promise","resolve","setTimeout","clearTimeout","_batchWithTimeout","timeout","iterator","pendingData","batchData","timer","clearTimer","startTimer","deleteTimer","next","res","race","done","value","batchWithTimeout","Infinity","getIterator","TypeError","defer","reject","promise","resolveFunc","rejectFunc","_buffer","resultQueue","readQueue","reading","ended","fulfillReadQueue","readDeferred","shift","error","fillQueue","deferred","asyncIterableIterator","syncBuffer","valueQueue","e","buffer","_collect","values","collect","Array","from","_concat","iterables","_syncConcat","concat","hasAnyAsync","find","itr","_consume","val","consume","_filter","filterFunc","filter","flatten","maybeItr","_map","func","map","flatMap","i","_flatTransform","concurrency","inflightCount","lastError","mapAndQueue","itrValue","asyncVal","flatTransform","curriedFunc","onceReadable","stream","once","_fromStream","read","_readableState","fromStream","merge","sources","Set","nextVal","delete","pipeline","firstFn","fns","previousFn","_parallelMap","transformError","wrapFunc","stopOnError","source","output","parallelMap","parallelFlatMap","parallelMerge","inputs","concurrentWork","Map","errCb","valueCb","notifyError","err","notifyDone","waitForQueue","queueNext","input","then","set","add","_reduce","start","nextItem","reduce","curriedStart","_take","count","taken","_syncTake","take","_asyncTap","tap","sleep","ms","_throttle","limit","interval","Number","isFinite","__throttle","sent","time","Date","now","elapsedMs","waitFor","throttle","addTime","a","b","seconds","nanoseconds","remainder","_asyncTime","config","total","process","hrtime","delta","progress","_syncTime","_transform","transform","_writeToStream","drainCb","notifyDrain","cleanup","removeListener","waitForDrain","write","writeToStream"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/streaming-iterables/dist/index.mjs"],"sourcesContent":["async function* _batch(size, iterable) {\n    let dataBatch = [];\n    for await (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction* _syncBatch(size, iterable) {\n    let dataBatch = [];\n    for (const data of iterable) {\n        dataBatch.push(data);\n        if (dataBatch.length === size) {\n            yield dataBatch;\n            dataBatch = [];\n        }\n    }\n    if (dataBatch.length > 0) {\n        yield dataBatch;\n    }\n}\nfunction batch(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batch(size, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _batch(size, iterable);\n    }\n    return _syncBatch(size, iterable);\n}\n\nconst TIMEOUT = Symbol('TIMEOUT');\nconst createTimer = (duration) => {\n    let timeoutId;\n    return [\n        new Promise(resolve => {\n            timeoutId = setTimeout(() => resolve(TIMEOUT), duration);\n        }),\n        () => {\n            clearTimeout(timeoutId);\n        },\n    ];\n};\n// Like `batch` but flushes early if the `timeout` is reached\n// NOTE: The strategy is to only hold onto a single item for a maximum of `timeout` ms.\nasync function* _batchWithTimeout(size, timeout, iterable) {\n    const iterator = iterable[Symbol.asyncIterator]();\n    let pendingData;\n    let batchData = [];\n    let timer;\n    let clearTimer;\n    const startTimer = () => {\n        deleteTimer();\n        [timer, clearTimer] = createTimer(timeout);\n    };\n    const deleteTimer = () => {\n        if (clearTimer) {\n            clearTimer();\n        }\n        timer = undefined;\n    };\n    pendingData = iterator.next();\n    while (true) {\n        const res = await (timer ? Promise.race([pendingData, timer]) : pendingData);\n        if (res === TIMEOUT || res.done) {\n            // Flush early (before we reach the batch size)\n            if (batchData.length) {\n                yield batchData;\n                batchData = [];\n            }\n            deleteTimer();\n            // And exit appropriately\n            if (res !== TIMEOUT) {\n                // done\n                break;\n            }\n            continue;\n        }\n        // Fetch next item early doors (before we potentially yield)\n        pendingData = iterator.next();\n        // Then handle the value\n        batchData.push(res.value);\n        if (batchData.length === 1) {\n            // Start timer once we have at least 1 item ready to go\n            startTimer();\n        }\n        if (batchData.length === size) {\n            yield batchData;\n            batchData = [];\n            deleteTimer();\n            continue;\n        }\n    }\n}\nfunction batchWithTimeout(size, timeout, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => batchWithTimeout(size, timeout, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] && timeout !== Infinity) {\n        return _batchWithTimeout(size, timeout, iterable);\n    }\n    // For sync iterables or an infinite timeout, the timeout is irrelevant so just fallback to regular `batch`.\n    return batch(size, iterable);\n}\n\nfunction getIterator(iterable) {\n    if (typeof iterable.next === 'function') {\n        return iterable;\n    }\n    if (typeof iterable[Symbol.iterator] === 'function') {\n        return iterable[Symbol.iterator]();\n    }\n    if (typeof iterable[Symbol.asyncIterator] === 'function') {\n        return iterable[Symbol.asyncIterator]();\n    }\n    throw new TypeError('\"values\" does not to conform to any of the iterator or iterable protocols');\n}\n\nfunction defer() {\n    let reject;\n    let resolve;\n    const promise = new Promise((resolveFunc, rejectFunc) => {\n        resolve = resolveFunc;\n        reject = rejectFunc;\n    });\n    return {\n        promise,\n        reject,\n        resolve,\n    };\n}\n\nfunction _buffer(size, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let reading = false;\n    let ended = false;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const readDeferred = readQueue.shift();\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                readDeferred.reject(error);\n            }\n            else {\n                readDeferred.resolve({ done: false, value });\n            }\n        }\n        while (readQueue.length > 0 && ended) {\n            const { resolve } = readQueue.shift();\n            resolve({ done: true, value: undefined });\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (resultQueue.length >= size) {\n            return;\n        }\n        reading = true;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n            }\n            else {\n                resultQueue.push({ value });\n            }\n        }\n        catch (error) {\n            ended = true;\n            resultQueue.push({ error });\n        }\n        fulfillReadQueue();\n        reading = false;\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length > 0) {\n            const { error, value } = resultQueue.shift();\n            if (error) {\n                throw error;\n            }\n            fillQueue();\n            return { done: false, value };\n        }\n        if (ended) {\n            return { done: true, value: undefined }; // stupid ts\n        }\n        const deferred = defer();\n        readQueue.push(deferred);\n        fillQueue();\n        return deferred.promise;\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction* syncBuffer(size, iterable) {\n    const valueQueue = [];\n    let e;\n    try {\n        for (const value of iterable) {\n            valueQueue.push(value);\n            if (valueQueue.length <= size) {\n                continue;\n            }\n            yield valueQueue.shift();\n        }\n    }\n    catch (error) {\n        e = error;\n    }\n    for (const value of valueQueue) {\n        yield value;\n    }\n    if (e) {\n        throw e;\n    }\n}\nfunction buffer(size, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => buffer(size, curriedIterable);\n    }\n    if (size === 0) {\n        return iterable;\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _buffer(size, iterable);\n    }\n    return syncBuffer(size, iterable);\n}\n\nasync function _collect(iterable) {\n    const values = [];\n    for await (const value of iterable) {\n        values.push(value);\n    }\n    return values;\n}\nfunction collect(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _collect(iterable);\n    }\n    return Array.from(iterable);\n}\n\nasync function* _concat(iterables) {\n    for await (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction* _syncConcat(iterables) {\n    for (const iterable of iterables) {\n        yield* iterable;\n    }\n}\nfunction concat(...iterables) {\n    const hasAnyAsync = iterables.find(itr => itr[Symbol.asyncIterator] !== undefined);\n    if (hasAnyAsync) {\n        return _concat(iterables);\n    }\n    else {\n        return _syncConcat(iterables);\n    }\n}\n\nasync function _consume(iterable) {\n    for await (const val of iterable) {\n        // do nothing\n    }\n}\nfunction consume(iterable) {\n    if (iterable[Symbol.asyncIterator]) {\n        return _consume(iterable);\n    }\n    for (const val of iterable) {\n        // do nothing\n    }\n}\n\nasync function* _filter(filterFunc, iterable) {\n    for await (const data of iterable) {\n        if (await filterFunc(data)) {\n            yield data;\n        }\n    }\n}\nfunction filter(filterFunc, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _filter(filterFunc, curriedIterable);\n    }\n    return _filter(filterFunc, iterable);\n}\n\nasync function* flatten(iterable) {\n    for await (const maybeItr of iterable) {\n        if (maybeItr && typeof maybeItr !== 'string' && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {\n            yield* flatten(maybeItr);\n        }\n        else {\n            yield maybeItr;\n        }\n    }\n}\n\nasync function* _map(func, iterable) {\n    for await (const val of iterable) {\n        yield await func(val);\n    }\n}\nfunction map(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => _map(func, curriedIterable);\n    }\n    return _map(func, iterable);\n}\n\nfunction flatMap(func, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => flatMap(func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(map(func, iterable)));\n}\n\nfunction _flatTransform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            if (value && value[Symbol.asyncIterator]) {\n                for await (const asyncVal of value) {\n                    resultQueue.push(asyncVal);\n                }\n            }\n            else {\n                resultQueue.push(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction flatTransform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? flatTransform(concurrency, curriedFunc, curriedIterable)\n            : flatTransform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(_flatTransform(concurrency, func, iterable)));\n}\n\nasync function onceReadable(stream) {\n    return new Promise(resolve => {\n        stream.once('readable', () => {\n            resolve();\n        });\n    });\n}\nasync function* _fromStream(stream) {\n    while (true) {\n        const data = stream.read();\n        if (data !== null) {\n            yield data;\n            continue;\n        }\n        if (stream._readableState.ended) {\n            break;\n        }\n        await onceReadable(stream);\n    }\n}\nfunction fromStream(stream) {\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n        return stream;\n    }\n    return _fromStream(stream);\n}\n\nasync function* merge(...iterables) {\n    const sources = new Set(iterables.map(getIterator));\n    while (sources.size > 0) {\n        for (const iterator of sources) {\n            const nextVal = await iterator.next();\n            if (nextVal.done) {\n                sources.delete(iterator);\n            }\n            else {\n                yield nextVal.value;\n            }\n        }\n    }\n}\n\nfunction pipeline(firstFn, ...fns) {\n    let previousFn = firstFn();\n    for (const func of fns) {\n        previousFn = func(previousFn);\n    }\n    return previousFn;\n}\n\nasync function* _parallelMap(concurrency, func, iterable) {\n    let transformError = null;\n    const wrapFunc = value => ({\n        value: func(value),\n    });\n    const stopOnError = async function* (source) {\n        for await (const value of source) {\n            if (transformError) {\n                return;\n            }\n            yield value;\n        }\n    };\n    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));\n    const itr = getIterator(output);\n    while (true) {\n        const { value, done } = await itr.next();\n        if (done) {\n            break;\n        }\n        try {\n            const val = await value.value;\n            if (!transformError) {\n                yield val;\n            }\n        }\n        catch (error) {\n            transformError = error;\n        }\n    }\n    if (transformError) {\n        throw transformError;\n    }\n}\nfunction parallelMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);\n    }\n    if (iterable === undefined) {\n        return curriedIterable => parallelMap(concurrency, func, curriedIterable);\n    }\n    if (concurrency === 1) {\n        return map(func, iterable);\n    }\n    return _parallelMap(concurrency, func, iterable);\n}\n\nfunction parallelFlatMap(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? parallelFlatMap(concurrency, curriedFunc, curriedIterable)\n            : parallelFlatMap(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);\n    }\n    return filter(i => i !== undefined && i !== null, flatten(parallelMap(concurrency, func, iterable)));\n}\n\nasync function* parallelMerge(...iterables) {\n    const inputs = iterables.map(getIterator);\n    const concurrentWork = new Set();\n    const values = new Map();\n    let lastError = null;\n    let errCb = null;\n    let valueCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDone = value => {\n        if (valueCb) {\n            valueCb(value);\n        }\n    };\n    const waitForQueue = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            reject(lastError);\n        }\n        if (values.size > 0) {\n            return resolve();\n        }\n        valueCb = resolve;\n        errCb = reject;\n    });\n    const queueNext = input => {\n        const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {\n            if (!done) {\n                values.set(input, value);\n            }\n            concurrentWork.delete(nextVal);\n        });\n        concurrentWork.add(nextVal);\n        nextVal.then(notifyDone, notifyError);\n    };\n    for (const input of inputs) {\n        queueNext(input);\n    }\n    while (true) {\n        // We technically don't have to check `values.size` as the for loop should have emptied it\n        // However I haven't yet found specs verifying that behavior, only tests\n        // the guard in waitForQueue() checking for values is in place for the same reason\n        if (concurrentWork.size === 0 && values.size === 0) {\n            return;\n        }\n        await waitForQueue();\n        for (const [input, value] of values) {\n            values.delete(input);\n            yield value;\n            queueNext(input);\n        }\n    }\n}\n\nasync function _reduce(func, start, iterable) {\n    let value = start;\n    for await (const nextItem of iterable) {\n        value = await func(value, nextItem);\n    }\n    return value;\n}\nfunction reduce(func, start, iterable) {\n    if (start === undefined) {\n        return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => reduce(func, start, curriedIterable);\n    }\n    return _reduce(func, start, iterable);\n}\n\nasync function* _take(count, iterable) {\n    let taken = 0;\n    for await (const val of iterable) {\n        yield await val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction* _syncTake(count, iterable) {\n    let taken = 0;\n    for (const val of iterable) {\n        yield val;\n        taken++;\n        if (taken >= count) {\n            break;\n        }\n    }\n}\nfunction take(count, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => take(count, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator]) {\n        return _take(count, iterable);\n    }\n    return _syncTake(count, iterable);\n}\n\nasync function* _asyncTap(func, iterable) {\n    for await (const val of iterable) {\n        await func(val);\n        yield val;\n    }\n}\nfunction tap(func, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _asyncTap(func, curriedIterable);\n    }\n    return _asyncTap(func, iterable);\n}\n\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\nfunction _throttle(limit, interval, iterable) {\n    if (!Number.isFinite(limit)) {\n        throw new TypeError('Expected `limit` to be a finite number');\n    }\n    if (limit <= 0) {\n        throw new TypeError('Expected `limit` to be greater than 0');\n    }\n    if (!Number.isFinite(interval)) {\n        throw new TypeError('Expected `interval` to be a finite number');\n    }\n    return (async function* __throttle() {\n        let sent = 0;\n        let time;\n        for await (const val of iterable) {\n            if (sent < limit) {\n                if (typeof time === 'undefined') {\n                    time = Date.now();\n                }\n                sent++;\n                yield val;\n                continue;\n            }\n            // Only wait if the interval hasn't already passed while we were\n            // yielding the previous values.\n            const elapsedMs = Date.now() - time;\n            const waitFor = interval - elapsedMs;\n            if (waitFor > 0) {\n                await sleep(waitFor);\n            }\n            time = Date.now();\n            sent = 1;\n            yield val;\n        }\n    })();\n}\nfunction throttle(limit, interval, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _throttle(limit, interval, curriedIterable);\n    }\n    return _throttle(limit, interval, iterable);\n}\n\nfunction addTime(a, b) {\n    let seconds = a[0] + b[0];\n    let nanoseconds = a[1] + b[1];\n    if (nanoseconds >= 1000000000) {\n        const remainder = nanoseconds % 1000000000;\n        seconds += (nanoseconds - remainder) / 1000000000;\n        nanoseconds = remainder;\n    }\n    return [seconds, nanoseconds];\n}\nasync function* _asyncTime(config, iterable) {\n    const itr = iterable[Symbol.asyncIterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = await itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction* _syncTime(config, iterable) {\n    const itr = iterable[Symbol.iterator]();\n    let total = [0, 0];\n    while (true) {\n        const start = process.hrtime();\n        const { value, done } = itr.next();\n        const delta = process.hrtime(start);\n        total = addTime(total, delta);\n        if (config.progress) {\n            config.progress(delta, total);\n        }\n        if (done) {\n            if (config.total) {\n                config.total(total);\n            }\n            return value;\n        }\n        yield value;\n    }\n}\nfunction time(config = {}, iterable) {\n    if (iterable === undefined) {\n        return curriedIterable => time(config, curriedIterable);\n    }\n    if (iterable[Symbol.asyncIterator] !== undefined) {\n        return _asyncTime(config, iterable);\n    }\n    else {\n        return _syncTime(config, iterable);\n    }\n}\n\nfunction _transform(concurrency, func, iterable) {\n    const iterator = getIterator(iterable);\n    const resultQueue = [];\n    const readQueue = [];\n    let ended = false;\n    let reading = false;\n    let inflightCount = 0;\n    let lastError = null;\n    function fulfillReadQueue() {\n        while (readQueue.length > 0 && resultQueue.length > 0) {\n            const { resolve } = readQueue.shift();\n            const value = resultQueue.shift();\n            resolve({ done: false, value });\n        }\n        while (readQueue.length > 0 && inflightCount === 0 && ended) {\n            const { resolve, reject } = readQueue.shift();\n            if (lastError) {\n                reject(lastError);\n                lastError = null;\n            }\n            else {\n                resolve({ done: true, value: undefined });\n            }\n        }\n    }\n    async function fillQueue() {\n        if (ended) {\n            fulfillReadQueue();\n            return;\n        }\n        if (reading) {\n            return;\n        }\n        if (inflightCount + resultQueue.length >= concurrency) {\n            return;\n        }\n        reading = true;\n        inflightCount++;\n        try {\n            const { done, value } = await iterator.next();\n            if (done) {\n                ended = true;\n                inflightCount--;\n                fulfillReadQueue();\n            }\n            else {\n                mapAndQueue(value);\n            }\n        }\n        catch (error) {\n            ended = true;\n            inflightCount--;\n            lastError = error;\n            fulfillReadQueue();\n        }\n        reading = false;\n        fillQueue();\n    }\n    async function mapAndQueue(itrValue) {\n        try {\n            const value = await func(itrValue);\n            resultQueue.push(value);\n        }\n        catch (error) {\n            ended = true;\n            lastError = error;\n        }\n        inflightCount--;\n        fulfillReadQueue();\n        fillQueue();\n    }\n    async function next() {\n        if (resultQueue.length === 0) {\n            const deferred = defer();\n            readQueue.push(deferred);\n            fillQueue();\n            return deferred.promise;\n        }\n        const value = resultQueue.shift();\n        fillQueue();\n        return { done: false, value };\n    }\n    const asyncIterableIterator = {\n        next,\n        [Symbol.asyncIterator]: () => asyncIterableIterator,\n    };\n    return asyncIterableIterator;\n}\nfunction transform(concurrency, func, iterable) {\n    if (func === undefined) {\n        return (curriedFunc, curriedIterable) => curriedIterable\n            ? transform(concurrency, curriedFunc, curriedIterable)\n            : transform(concurrency, curriedFunc);\n    }\n    if (iterable === undefined) {\n        return (curriedIterable) => transform(concurrency, func, curriedIterable);\n    }\n    return _transform(concurrency, func, iterable);\n}\n\nasync function _writeToStream(stream, iterable) {\n    let lastError = null;\n    let errCb = null;\n    let drainCb = null;\n    const notifyError = err => {\n        lastError = err;\n        if (errCb) {\n            errCb(err);\n        }\n    };\n    const notifyDrain = () => {\n        if (drainCb) {\n            drainCb();\n        }\n    };\n    const cleanup = () => {\n        stream.removeListener('error', notifyError);\n        stream.removeListener('drain', notifyDrain);\n    };\n    stream.once('error', notifyError);\n    const waitForDrain = () => new Promise((resolve, reject) => {\n        if (lastError) {\n            return reject(lastError);\n        }\n        stream.once('drain', notifyDrain);\n        drainCb = resolve;\n        errCb = reject;\n    });\n    for await (const value of iterable) {\n        if (stream.write(value) === false) {\n            await waitForDrain();\n        }\n        if (lastError) {\n            break;\n        }\n    }\n    cleanup();\n    if (lastError) {\n        throw lastError;\n    }\n}\nfunction writeToStream(stream, iterable) {\n    if (iterable === undefined) {\n        return (curriedIterable) => _writeToStream(stream, curriedIterable);\n    }\n    return _writeToStream(stream, iterable);\n}\n\nexport { batch, batchWithTimeout, buffer, collect, concat, consume, filter, flatMap, flatTransform, flatten, fromStream, getIterator, map, merge, parallelFlatMap, parallelMap, parallelMerge, pipeline, reduce, take, tap, throttle, time, transform, writeToStream };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}