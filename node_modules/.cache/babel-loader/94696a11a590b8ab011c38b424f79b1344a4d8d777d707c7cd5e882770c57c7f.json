{"ast":null,"code":"import \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport { asyncIterableReader, bytesReader, createDecoder } from './decoder.js';\nexport class CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n    return decodeIndexerComplete(bytesReader(bytes));\n  }\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable));\n  }\n}\nasync function decodeIndexerComplete(reader) {\n  const decoder = createDecoder(reader);\n  const {\n    version,\n    roots\n  } = await decoder.header();\n  return new CarIndexer(version, roots, decoder.blocksIndex());\n}","map":{"version":3,"names":["asyncIterableReader","bytesReader","createDecoder","CarIndexer","constructor","version","roots","iterator","_version","_roots","_iterator","getRoots","Symbol","asyncIterator","fromBytes","bytes","Uint8Array","TypeError","decodeIndexerComplete","fromIterable","asyncIterable","reader","decoder","header","blocksIndex"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/@ipld/car/esm/lib/indexer.js"],"sourcesContent":["import {\n  asyncIterableReader,\n  bytesReader,\n  createDecoder\n} from './decoder.js';\nexport class CarIndexer {\n  constructor(version, roots, iterator) {\n    this._version = version;\n    this._roots = roots;\n    this._iterator = iterator;\n  }\n  get version() {\n    return this._version;\n  }\n  async getRoots() {\n    return this._roots;\n  }\n  [Symbol.asyncIterator]() {\n    return this._iterator;\n  }\n  static async fromBytes(bytes) {\n    if (!(bytes instanceof Uint8Array)) {\n      throw new TypeError('fromBytes() requires a Uint8Array');\n    }\n    return decodeIndexerComplete(bytesReader(bytes));\n  }\n  static async fromIterable(asyncIterable) {\n    if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === 'function')) {\n      throw new TypeError('fromIterable() requires an async iterable');\n    }\n    return decodeIndexerComplete(asyncIterableReader(asyncIterable));\n  }\n}\nasync function decodeIndexerComplete(reader) {\n  const decoder = createDecoder(reader);\n  const {version, roots} = await decoder.header();\n  return new CarIndexer(version, roots, decoder.blocksIndex());\n}"],"mappings":";;AAAA,SACEA,mBAAmB,EACnBC,WAAW,EACXC,aAAa,QACR,cAAc;AACrB,OAAO,MAAMC,UAAU,CAAC;EACtBC,WAAW,CAACC,OAAO,EAAEC,KAAK,EAAEC,QAAQ,EAAE;IACpC,IAAI,CAACC,QAAQ,GAAGH,OAAO;IACvB,IAAI,CAACI,MAAM,GAAGH,KAAK;IACnB,IAAI,CAACI,SAAS,GAAGH,QAAQ;EAC3B;EACA,IAAIF,OAAO,GAAG;IACZ,OAAO,IAAI,CAACG,QAAQ;EACtB;EACA,MAAMG,QAAQ,GAAG;IACf,OAAO,IAAI,CAACF,MAAM;EACpB;EACA,CAACG,MAAM,CAACC,aAAa,IAAI;IACvB,OAAO,IAAI,CAACH,SAAS;EACvB;EACA,aAAaI,SAAS,CAACC,KAAK,EAAE;IAC5B,IAAI,EAAEA,KAAK,YAAYC,UAAU,CAAC,EAAE;MAClC,MAAM,IAAIC,SAAS,CAAC,mCAAmC,CAAC;IAC1D;IACA,OAAOC,qBAAqB,CAACjB,WAAW,CAACc,KAAK,CAAC,CAAC;EAClD;EACA,aAAaI,YAAY,CAACC,aAAa,EAAE;IACvC,IAAI,CAACA,aAAa,IAAI,EAAE,OAAOA,aAAa,CAACR,MAAM,CAACC,aAAa,CAAC,KAAK,UAAU,CAAC,EAAE;MAClF,MAAM,IAAII,SAAS,CAAC,2CAA2C,CAAC;IAClE;IACA,OAAOC,qBAAqB,CAAClB,mBAAmB,CAACoB,aAAa,CAAC,CAAC;EAClE;AACF;AACA,eAAeF,qBAAqB,CAACG,MAAM,EAAE;EAC3C,MAAMC,OAAO,GAAGpB,aAAa,CAACmB,MAAM,CAAC;EACrC,MAAM;IAAChB,OAAO;IAAEC;EAAK,CAAC,GAAG,MAAMgB,OAAO,CAACC,MAAM,EAAE;EAC/C,OAAO,IAAIpB,UAAU,CAACE,OAAO,EAAEC,KAAK,EAAEgB,OAAO,CAACE,WAAW,EAAE,CAAC;AAC9D"},"metadata":{},"sourceType":"module","externalDependencies":[]}