{"ast":null,"code":"import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack({\n  input,\n  blockstore: userBlockstore,\n  hasher,\n  maxChunkSize,\n  maxChildrenPerNode,\n  wrapWithDirectory,\n  rawLeaves\n}) {\n  if (!input || Array.isArray(input) && !input.length) {\n    throw new Error('missing input file(s)');\n  }\n  const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();\n  // Consume the source\n  const rootEntry = await last(pipe(getNormaliser(input), source => importer(source, blockstore, {\n    ...unixfsImporterOptionsDefault,\n    hasher: hasher || unixfsImporterOptionsDefault.hasher,\n    maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n    maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n    wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n    rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n  })));\n  if (!rootEntry || !rootEntry.cid) {\n    throw new Error('given input could not be parsed correctly');\n  }\n  const root = rootEntry.cid;\n  const {\n    writer,\n    out: carOut\n  } = await CarWriter.create([root]);\n  const carOutIter = carOut[Symbol.asyncIterator]();\n  let writingPromise;\n  const writeAll = async () => {\n    for await (const block of blockstore.blocks()) {\n      // `await` will block until all bytes in `carOut` are consumed by the user\n      // so we have backpressure here\n      await writer.put(block);\n    }\n    await writer.close();\n    if (!userBlockstore) {\n      await blockstore.close();\n    }\n  };\n  const out = {\n    [Symbol.asyncIterator]() {\n      if (writingPromise != null) {\n        throw new Error('Multiple iterator not supported');\n      }\n      // don't start writing until the user starts consuming the iterator\n      writingPromise = writeAll();\n      return {\n        async next() {\n          const result = await carOutIter.next();\n          if (result.done) {\n            await writingPromise; // any errors will propagate from here\n          }\n\n          return result;\n        }\n      };\n    }\n  };\n  return {\n    root,\n    out\n  };\n}","map":{"version":3,"names":["last","pipe","CarWriter","importer","getNormaliser","MemoryBlockStore","unixfsImporterOptionsDefault","pack","input","blockstore","userBlockstore","hasher","maxChunkSize","maxChildrenPerNode","wrapWithDirectory","rawLeaves","Array","isArray","length","Error","rootEntry","source","cid","root","writer","out","carOut","create","carOutIter","Symbol","asyncIterator","writingPromise","writeAll","block","blocks","put","close","next","result","done"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/ipfs-car/dist/esm/pack/index.js"],"sourcesContent":["import last from 'it-last';\nimport pipe from 'it-pipe';\nimport { CarWriter } from '@ipld/car';\nimport { importer } from 'ipfs-unixfs-importer';\nimport { getNormaliser } from \"./utils/normalise-input.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\nimport { unixfsImporterOptionsDefault } from \"./constants.js\";\nexport async function pack({ input, blockstore: userBlockstore, hasher, maxChunkSize, maxChildrenPerNode, wrapWithDirectory, rawLeaves }) {\n    if (!input || (Array.isArray(input) && !input.length)) {\n        throw new Error('missing input file(s)');\n    }\n    const blockstore = userBlockstore ? userBlockstore : new MemoryBlockStore();\n    // Consume the source\n    const rootEntry = await last(pipe(getNormaliser(input), (source) => importer(source, blockstore, {\n        ...unixfsImporterOptionsDefault,\n        hasher: hasher || unixfsImporterOptionsDefault.hasher,\n        maxChunkSize: maxChunkSize || unixfsImporterOptionsDefault.maxChunkSize,\n        maxChildrenPerNode: maxChildrenPerNode || unixfsImporterOptionsDefault.maxChildrenPerNode,\n        wrapWithDirectory: wrapWithDirectory === false ? false : unixfsImporterOptionsDefault.wrapWithDirectory,\n        rawLeaves: rawLeaves == null ? unixfsImporterOptionsDefault.rawLeaves : rawLeaves\n    })));\n    if (!rootEntry || !rootEntry.cid) {\n        throw new Error('given input could not be parsed correctly');\n    }\n    const root = rootEntry.cid;\n    const { writer, out: carOut } = await CarWriter.create([root]);\n    const carOutIter = carOut[Symbol.asyncIterator]();\n    let writingPromise;\n    const writeAll = async () => {\n        for await (const block of blockstore.blocks()) {\n            // `await` will block until all bytes in `carOut` are consumed by the user\n            // so we have backpressure here\n            await writer.put(block);\n        }\n        await writer.close();\n        if (!userBlockstore) {\n            await blockstore.close();\n        }\n    };\n    const out = {\n        [Symbol.asyncIterator]() {\n            if (writingPromise != null) {\n                throw new Error('Multiple iterator not supported');\n            }\n            // don't start writing until the user starts consuming the iterator\n            writingPromise = writeAll();\n            return {\n                async next() {\n                    const result = await carOutIter.next();\n                    if (result.done) {\n                        await writingPromise; // any errors will propagate from here\n                    }\n                    return result;\n                }\n            };\n        }\n    };\n    return { root, out };\n}\n"],"mappings":"AAAA,OAAOA,IAAI,MAAM,SAAS;AAC1B,OAAOC,IAAI,MAAM,SAAS;AAC1B,SAASC,SAAS,QAAQ,WAAW;AACrC,SAASC,QAAQ,QAAQ,sBAAsB;AAC/C,SAASC,aAAa,QAAQ,4BAA4B;AAC1D,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D,SAASC,4BAA4B,QAAQ,gBAAgB;AAC7D,OAAO,eAAeC,IAAI,CAAC;EAAEC,KAAK;EAAEC,UAAU,EAAEC,cAAc;EAAEC,MAAM;EAAEC,YAAY;EAAEC,kBAAkB;EAAEC,iBAAiB;EAAEC;AAAU,CAAC,EAAE;EACtI,IAAI,CAACP,KAAK,IAAKQ,KAAK,CAACC,OAAO,CAACT,KAAK,CAAC,IAAI,CAACA,KAAK,CAACU,MAAO,EAAE;IACnD,MAAM,IAAIC,KAAK,CAAC,uBAAuB,CAAC;EAC5C;EACA,MAAMV,UAAU,GAAGC,cAAc,GAAGA,cAAc,GAAG,IAAIL,gBAAgB,EAAE;EAC3E;EACA,MAAMe,SAAS,GAAG,MAAMpB,IAAI,CAACC,IAAI,CAACG,aAAa,CAACI,KAAK,CAAC,EAAGa,MAAM,IAAKlB,QAAQ,CAACkB,MAAM,EAAEZ,UAAU,EAAE;IAC7F,GAAGH,4BAA4B;IAC/BK,MAAM,EAAEA,MAAM,IAAIL,4BAA4B,CAACK,MAAM;IACrDC,YAAY,EAAEA,YAAY,IAAIN,4BAA4B,CAACM,YAAY;IACvEC,kBAAkB,EAAEA,kBAAkB,IAAIP,4BAA4B,CAACO,kBAAkB;IACzFC,iBAAiB,EAAEA,iBAAiB,KAAK,KAAK,GAAG,KAAK,GAAGR,4BAA4B,CAACQ,iBAAiB;IACvGC,SAAS,EAAEA,SAAS,IAAI,IAAI,GAAGT,4BAA4B,CAACS,SAAS,GAAGA;EAC5E,CAAC,CAAC,CAAC,CAAC;EACJ,IAAI,CAACK,SAAS,IAAI,CAACA,SAAS,CAACE,GAAG,EAAE;IAC9B,MAAM,IAAIH,KAAK,CAAC,2CAA2C,CAAC;EAChE;EACA,MAAMI,IAAI,GAAGH,SAAS,CAACE,GAAG;EAC1B,MAAM;IAAEE,MAAM;IAAEC,GAAG,EAAEC;EAAO,CAAC,GAAG,MAAMxB,SAAS,CAACyB,MAAM,CAAC,CAACJ,IAAI,CAAC,CAAC;EAC9D,MAAMK,UAAU,GAAGF,MAAM,CAACG,MAAM,CAACC,aAAa,CAAC,EAAE;EACjD,IAAIC,cAAc;EAClB,MAAMC,QAAQ,GAAG,YAAY;IACzB,WAAW,MAAMC,KAAK,IAAIxB,UAAU,CAACyB,MAAM,EAAE,EAAE;MAC3C;MACA;MACA,MAAMV,MAAM,CAACW,GAAG,CAACF,KAAK,CAAC;IAC3B;IACA,MAAMT,MAAM,CAACY,KAAK,EAAE;IACpB,IAAI,CAAC1B,cAAc,EAAE;MACjB,MAAMD,UAAU,CAAC2B,KAAK,EAAE;IAC5B;EACJ,CAAC;EACD,MAAMX,GAAG,GAAG;IACR,CAACI,MAAM,CAACC,aAAa,IAAI;MACrB,IAAIC,cAAc,IAAI,IAAI,EAAE;QACxB,MAAM,IAAIZ,KAAK,CAAC,iCAAiC,CAAC;MACtD;MACA;MACAY,cAAc,GAAGC,QAAQ,EAAE;MAC3B,OAAO;QACH,MAAMK,IAAI,GAAG;UACT,MAAMC,MAAM,GAAG,MAAMV,UAAU,CAACS,IAAI,EAAE;UACtC,IAAIC,MAAM,CAACC,IAAI,EAAE;YACb,MAAMR,cAAc,CAAC,CAAC;UAC1B;;UACA,OAAOO,MAAM;QACjB;MACJ,CAAC;IACL;EACJ,CAAC;EACD,OAAO;IAAEf,IAAI;IAAEE;EAAI,CAAC;AACxB"},"metadata":{},"sourceType":"module","externalDependencies":[]}