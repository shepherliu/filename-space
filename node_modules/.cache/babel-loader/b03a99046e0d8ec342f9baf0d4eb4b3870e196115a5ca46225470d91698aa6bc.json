{"ast":null,"code":"import \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport { CID } from 'multiformats/cid';\nimport { createEncoder, createHeader } from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport { bytesReader, readHeader } from './decoder.js';\nexport class CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    const cid = CID.asCID(block.cid);\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n  static create(roots) {\n    roots = toRoots(roots);\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static createAppender() {\n    const {\n      encoder,\n      iterator\n    } = encodeWriter();\n    encoder.setRoots = () => Promise.resolve();\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = bytesReader(bytes);\n    await readHeader(reader);\n    const newHeader = createHeader(roots);\n    if (reader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);\n    }\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n}\nexport class CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n    this._iterating = true;\n    return this._iterator;\n  }\n}\nfunction encodeWriter() {\n  const iw = iteratorChannel();\n  const {\n    writer,\n    iterator\n  } = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid];\n  }\n  const _roots = [];\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    _roots.push(_root);\n  }\n  return _roots;\n}\nexport const __browser = true;","map":{"version":3,"names":["CID","createEncoder","createHeader","create","iteratorChannel","bytesReader","readHeader","CarWriter","constructor","roots","encoder","_encoder","_mutex","setRoots","_ended","put","block","bytes","Uint8Array","cid","TypeError","Error","asCID","then","writeBlock","close","toRoots","iterator","encodeWriter","writer","out","CarWriterOut","createAppender","Promise","resolve","updateRootsInBytes","reader","newHeader","pos","length","set","_iterator","Symbol","asyncIterator","_iterating","iw","undefined","Array","isArray","_roots","root","_root","push","__browser"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/@ipld/car/esm/lib/writer-browser.js"],"sourcesContent":["import { CID } from 'multiformats/cid';\nimport {\n  createEncoder,\n  createHeader\n} from './encoder.js';\nimport { create as iteratorChannel } from './iterator-channel.js';\nimport {\n  bytesReader,\n  readHeader\n} from './decoder.js';\nexport class CarWriter {\n  constructor(roots, encoder) {\n    this._encoder = encoder;\n    this._mutex = encoder.setRoots(roots);\n    this._ended = false;\n  }\n  async put(block) {\n    if (!(block.bytes instanceof Uint8Array) || !block.cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    const cid = CID.asCID(block.cid);\n    if (!cid) {\n      throw new TypeError('Can only write {cid, bytes} objects');\n    }\n    this._mutex = this._mutex.then(() => this._encoder.writeBlock({\n      cid,\n      bytes: block.bytes\n    }));\n    return this._mutex;\n  }\n  async close() {\n    if (this._ended) {\n      throw new Error('Already closed');\n    }\n    await this._mutex;\n    this._ended = true;\n    return this._encoder.close();\n  }\n  static create(roots) {\n    roots = toRoots(roots);\n    const {encoder, iterator} = encodeWriter();\n    const writer = new CarWriter(roots, encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static createAppender() {\n    const {encoder, iterator} = encodeWriter();\n    encoder.setRoots = () => Promise.resolve();\n    const writer = new CarWriter([], encoder);\n    const out = new CarWriterOut(iterator);\n    return {\n      writer,\n      out\n    };\n  }\n  static async updateRootsInBytes(bytes, roots) {\n    const reader = bytesReader(bytes);\n    await readHeader(reader);\n    const newHeader = createHeader(roots);\n    if (reader.pos !== newHeader.length) {\n      throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${ reader.pos } bytes, new header is ${ newHeader.length } bytes)`);\n    }\n    bytes.set(newHeader, 0);\n    return bytes;\n  }\n}\nexport class CarWriterOut {\n  constructor(iterator) {\n    this._iterator = iterator;\n  }\n  [Symbol.asyncIterator]() {\n    if (this._iterating) {\n      throw new Error('Multiple iterator not supported');\n    }\n    this._iterating = true;\n    return this._iterator;\n  }\n}\nfunction encodeWriter() {\n  const iw = iteratorChannel();\n  const {writer, iterator} = iw;\n  const encoder = createEncoder(writer);\n  return {\n    encoder,\n    iterator\n  };\n}\nfunction toRoots(roots) {\n  if (roots === undefined) {\n    return [];\n  }\n  if (!Array.isArray(roots)) {\n    const cid = CID.asCID(roots);\n    if (!cid) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    return [cid];\n  }\n  const _roots = [];\n  for (const root of roots) {\n    const _root = CID.asCID(root);\n    if (!_root) {\n      throw new TypeError('roots must be a single CID or an array of CIDs');\n    }\n    _roots.push(_root);\n  }\n  return _roots;\n}\nexport const __browser = true;"],"mappings":";;;AAAA,SAASA,GAAG,QAAQ,kBAAkB;AACtC,SACEC,aAAa,EACbC,YAAY,QACP,cAAc;AACrB,SAASC,MAAM,IAAIC,eAAe,QAAQ,uBAAuB;AACjE,SACEC,WAAW,EACXC,UAAU,QACL,cAAc;AACrB,OAAO,MAAMC,SAAS,CAAC;EACrBC,WAAW,CAACC,KAAK,EAAEC,OAAO,EAAE;IAC1B,IAAI,CAACC,QAAQ,GAAGD,OAAO;IACvB,IAAI,CAACE,MAAM,GAAGF,OAAO,CAACG,QAAQ,CAACJ,KAAK,CAAC;IACrC,IAAI,CAACK,MAAM,GAAG,KAAK;EACrB;EACA,MAAMC,GAAG,CAACC,KAAK,EAAE;IACf,IAAI,EAAEA,KAAK,CAACC,KAAK,YAAYC,UAAU,CAAC,IAAI,CAACF,KAAK,CAACG,GAAG,EAAE;MACtD,MAAM,IAAIC,SAAS,CAAC,qCAAqC,CAAC;IAC5D;IACA,IAAI,IAAI,CAACN,MAAM,EAAE;MACf,MAAM,IAAIO,KAAK,CAAC,gBAAgB,CAAC;IACnC;IACA,MAAMF,GAAG,GAAGnB,GAAG,CAACsB,KAAK,CAACN,KAAK,CAACG,GAAG,CAAC;IAChC,IAAI,CAACA,GAAG,EAAE;MACR,MAAM,IAAIC,SAAS,CAAC,qCAAqC,CAAC;IAC5D;IACA,IAAI,CAACR,MAAM,GAAG,IAAI,CAACA,MAAM,CAACW,IAAI,CAAC,MAAM,IAAI,CAACZ,QAAQ,CAACa,UAAU,CAAC;MAC5DL,GAAG;MACHF,KAAK,EAAED,KAAK,CAACC;IACf,CAAC,CAAC,CAAC;IACH,OAAO,IAAI,CAACL,MAAM;EACpB;EACA,MAAMa,KAAK,GAAG;IACZ,IAAI,IAAI,CAACX,MAAM,EAAE;MACf,MAAM,IAAIO,KAAK,CAAC,gBAAgB,CAAC;IACnC;IACA,MAAM,IAAI,CAACT,MAAM;IACjB,IAAI,CAACE,MAAM,GAAG,IAAI;IAClB,OAAO,IAAI,CAACH,QAAQ,CAACc,KAAK,EAAE;EAC9B;EACA,OAAOtB,MAAM,CAACM,KAAK,EAAE;IACnBA,KAAK,GAAGiB,OAAO,CAACjB,KAAK,CAAC;IACtB,MAAM;MAACC,OAAO;MAAEiB;IAAQ,CAAC,GAAGC,YAAY,EAAE;IAC1C,MAAMC,MAAM,GAAG,IAAItB,SAAS,CAACE,KAAK,EAAEC,OAAO,CAAC;IAC5C,MAAMoB,GAAG,GAAG,IAAIC,YAAY,CAACJ,QAAQ,CAAC;IACtC,OAAO;MACLE,MAAM;MACNC;IACF,CAAC;EACH;EACA,OAAOE,cAAc,GAAG;IACtB,MAAM;MAACtB,OAAO;MAAEiB;IAAQ,CAAC,GAAGC,YAAY,EAAE;IAC1ClB,OAAO,CAACG,QAAQ,GAAG,MAAMoB,OAAO,CAACC,OAAO,EAAE;IAC1C,MAAML,MAAM,GAAG,IAAItB,SAAS,CAAC,EAAE,EAAEG,OAAO,CAAC;IACzC,MAAMoB,GAAG,GAAG,IAAIC,YAAY,CAACJ,QAAQ,CAAC;IACtC,OAAO;MACLE,MAAM;MACNC;IACF,CAAC;EACH;EACA,aAAaK,kBAAkB,CAAClB,KAAK,EAAER,KAAK,EAAE;IAC5C,MAAM2B,MAAM,GAAG/B,WAAW,CAACY,KAAK,CAAC;IACjC,MAAMX,UAAU,CAAC8B,MAAM,CAAC;IACxB,MAAMC,SAAS,GAAGnC,YAAY,CAACO,KAAK,CAAC;IACrC,IAAI2B,MAAM,CAACE,GAAG,KAAKD,SAAS,CAACE,MAAM,EAAE;MACnC,MAAM,IAAIlB,KAAK,CAAE,+EAA+Ee,MAAM,CAACE,GAAK,yBAAyBD,SAAS,CAACE,MAAQ,SAAQ,CAAC;IAClK;IACAtB,KAAK,CAACuB,GAAG,CAACH,SAAS,EAAE,CAAC,CAAC;IACvB,OAAOpB,KAAK;EACd;AACF;AACA,OAAO,MAAMc,YAAY,CAAC;EACxBvB,WAAW,CAACmB,QAAQ,EAAE;IACpB,IAAI,CAACc,SAAS,GAAGd,QAAQ;EAC3B;EACA,CAACe,MAAM,CAACC,aAAa,IAAI;IACvB,IAAI,IAAI,CAACC,UAAU,EAAE;MACnB,MAAM,IAAIvB,KAAK,CAAC,iCAAiC,CAAC;IACpD;IACA,IAAI,CAACuB,UAAU,GAAG,IAAI;IACtB,OAAO,IAAI,CAACH,SAAS;EACvB;AACF;AACA,SAASb,YAAY,GAAG;EACtB,MAAMiB,EAAE,GAAGzC,eAAe,EAAE;EAC5B,MAAM;IAACyB,MAAM;IAAEF;EAAQ,CAAC,GAAGkB,EAAE;EAC7B,MAAMnC,OAAO,GAAGT,aAAa,CAAC4B,MAAM,CAAC;EACrC,OAAO;IACLnB,OAAO;IACPiB;EACF,CAAC;AACH;AACA,SAASD,OAAO,CAACjB,KAAK,EAAE;EACtB,IAAIA,KAAK,KAAKqC,SAAS,EAAE;IACvB,OAAO,EAAE;EACX;EACA,IAAI,CAACC,KAAK,CAACC,OAAO,CAACvC,KAAK,CAAC,EAAE;IACzB,MAAMU,GAAG,GAAGnB,GAAG,CAACsB,KAAK,CAACb,KAAK,CAAC;IAC5B,IAAI,CAACU,GAAG,EAAE;MACR,MAAM,IAAIC,SAAS,CAAC,gDAAgD,CAAC;IACvE;IACA,OAAO,CAACD,GAAG,CAAC;EACd;EACA,MAAM8B,MAAM,GAAG,EAAE;EACjB,KAAK,MAAMC,IAAI,IAAIzC,KAAK,EAAE;IACxB,MAAM0C,KAAK,GAAGnD,GAAG,CAACsB,KAAK,CAAC4B,IAAI,CAAC;IAC7B,IAAI,CAACC,KAAK,EAAE;MACV,MAAM,IAAI/B,SAAS,CAAC,gDAAgD,CAAC;IACvE;IACA6B,MAAM,CAACG,IAAI,CAACD,KAAK,CAAC;EACpB;EACA,OAAOF,MAAM;AACf;AACA,OAAO,MAAMI,SAAS,GAAG,IAAI"},"metadata":{},"sourceType":"module","externalDependencies":[]}