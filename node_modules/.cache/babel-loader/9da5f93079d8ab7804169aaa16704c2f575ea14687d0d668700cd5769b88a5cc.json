{"ast":null,"code":"import { equals } from 'uint8arrays/equals';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { BaseBlockstore } from 'blockstore-core';\nexport class VerifyingGetOnlyBlockStore extends BaseBlockstore {\n  constructor(blockstore) {\n    super();\n    this.store = blockstore;\n  }\n  async get(cid) {\n    const res = await this.store.get(cid);\n    if (!res) {\n      throw new Error(`Incomplete CAR. Block missing for CID ${cid}`);\n    }\n    if (!isValid({\n      cid,\n      bytes: res\n    })) {\n      throw new Error(`Invalid CAR. Hash of block data does not match CID ${cid}`);\n    }\n    return res;\n  }\n  static fromBlockstore(b) {\n    return new VerifyingGetOnlyBlockStore(b);\n  }\n  static fromCarReader(cr) {\n    return new VerifyingGetOnlyBlockStore({\n      // Return bytes in the same fashion as a Blockstore implementation\n      get: async cid => {\n        const block = await cr.get(cid);\n        return block === null || block === void 0 ? void 0 : block.bytes;\n      }\n    });\n  }\n}\nasync function isValid({\n  cid,\n  bytes\n}) {\n  const hash = await sha256.digest(bytes);\n  return equals(hash.digest, cid.multihash.digest);\n}","map":{"version":3,"names":["equals","sha256","BaseBlockstore","VerifyingGetOnlyBlockStore","constructor","blockstore","store","get","cid","res","Error","isValid","bytes","fromBlockstore","b","fromCarReader","cr","block","hash","digest","multihash"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/ipfs-car/dist/esm/unpack/utils/verifying-get-only-blockstore.js"],"sourcesContent":["import { equals } from 'uint8arrays/equals';\nimport { sha256 } from 'multiformats/hashes/sha2';\nimport { BaseBlockstore } from 'blockstore-core';\nexport class VerifyingGetOnlyBlockStore extends BaseBlockstore {\n    constructor(blockstore) {\n        super();\n        this.store = blockstore;\n    }\n    async get(cid) {\n        const res = await this.store.get(cid);\n        if (!res) {\n            throw new Error(`Incomplete CAR. Block missing for CID ${cid}`);\n        }\n        if (!isValid({ cid, bytes: res })) {\n            throw new Error(`Invalid CAR. Hash of block data does not match CID ${cid}`);\n        }\n        return res;\n    }\n    static fromBlockstore(b) {\n        return new VerifyingGetOnlyBlockStore(b);\n    }\n    static fromCarReader(cr) {\n        return new VerifyingGetOnlyBlockStore({\n            // Return bytes in the same fashion as a Blockstore implementation\n            get: async (cid) => {\n                const block = await cr.get(cid);\n                return block === null || block === void 0 ? void 0 : block.bytes;\n            }\n        });\n    }\n}\nasync function isValid({ cid, bytes }) {\n    const hash = await sha256.digest(bytes);\n    return equals(hash.digest, cid.multihash.digest);\n}\n"],"mappings":"AAAA,SAASA,MAAM,QAAQ,oBAAoB;AAC3C,SAASC,MAAM,QAAQ,0BAA0B;AACjD,SAASC,cAAc,QAAQ,iBAAiB;AAChD,OAAO,MAAMC,0BAA0B,SAASD,cAAc,CAAC;EAC3DE,WAAW,CAACC,UAAU,EAAE;IACpB,KAAK,EAAE;IACP,IAAI,CAACC,KAAK,GAAGD,UAAU;EAC3B;EACA,MAAME,GAAG,CAACC,GAAG,EAAE;IACX,MAAMC,GAAG,GAAG,MAAM,IAAI,CAACH,KAAK,CAACC,GAAG,CAACC,GAAG,CAAC;IACrC,IAAI,CAACC,GAAG,EAAE;MACN,MAAM,IAAIC,KAAK,CAAE,yCAAwCF,GAAI,EAAC,CAAC;IACnE;IACA,IAAI,CAACG,OAAO,CAAC;MAAEH,GAAG;MAAEI,KAAK,EAAEH;IAAI,CAAC,CAAC,EAAE;MAC/B,MAAM,IAAIC,KAAK,CAAE,sDAAqDF,GAAI,EAAC,CAAC;IAChF;IACA,OAAOC,GAAG;EACd;EACA,OAAOI,cAAc,CAACC,CAAC,EAAE;IACrB,OAAO,IAAIX,0BAA0B,CAACW,CAAC,CAAC;EAC5C;EACA,OAAOC,aAAa,CAACC,EAAE,EAAE;IACrB,OAAO,IAAIb,0BAA0B,CAAC;MAClC;MACAI,GAAG,EAAE,MAAOC,GAAG,IAAK;QAChB,MAAMS,KAAK,GAAG,MAAMD,EAAE,CAACT,GAAG,CAACC,GAAG,CAAC;QAC/B,OAAOS,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAACL,KAAK;MACpE;IACJ,CAAC,CAAC;EACN;AACJ;AACA,eAAeD,OAAO,CAAC;EAAEH,GAAG;EAAEI;AAAM,CAAC,EAAE;EACnC,MAAMM,IAAI,GAAG,MAAMjB,MAAM,CAACkB,MAAM,CAACP,KAAK,CAAC;EACvC,OAAOZ,MAAM,CAACkB,IAAI,CAACC,MAAM,EAAEX,GAAG,CAACY,SAAS,CAACD,MAAM,CAAC;AACpD"},"metadata":{},"sourceType":"module","externalDependencies":[]}