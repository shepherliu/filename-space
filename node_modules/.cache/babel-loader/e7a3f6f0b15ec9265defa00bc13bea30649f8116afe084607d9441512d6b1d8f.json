{"ast":null,"code":"import \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport extractDataFromBlock from '../../../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js';\nimport { UnixFS } from 'ipfs-unixfs';\nimport errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\nasync function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += buf.length;\n    return streamPosition;\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  let file;\n  try {\n    file = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (file.data && file.data.length) {\n    const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += file.data.length;\n  }\n  let childStart = streamPosition;\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i];\n    const childEnd = streamPosition + file.blockSizes[i];\n    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n      const block = await blockstore.get(childLink.Hash, {\n        signal: options.signal\n      });\n      let child;\n      switch (childLink.Hash.code) {\n        case dagPb.code:\n          child = await dagPb.decode(block);\n          break;\n        case raw.code:\n          child = block;\n          break;\n        case dagCbor.code:\n          child = await dagCbor.decode(block);\n          break;\n        default:\n          throw Error(`Unsupported codec: ${childLink.Hash.code}`);\n      }\n      for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n        streamPosition += buf.length;\n        yield buf;\n      }\n    }\n    streamPosition = childEnd;\n    childStart = childEnd + 1;\n  }\n}\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent(options = {}) {\n    const fileSize = unixfs.fileSize();\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n    const {\n      offset,\n      length\n    } = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n  return yieldFileContent;\n};\nexport default fileContent;","map":{"version":3,"names":["extractDataFromBlock","validateOffsetAndLength","UnixFS","errCode","dagPb","dagCbor","raw","emitBytes","blockstore","node","start","end","streamPosition","options","Uint8Array","buf","length","Data","Error","file","unmarshal","err","data","childStart","i","Links","childLink","childEnd","blockSizes","block","get","Hash","signal","child","code","decode","fileContent","cid","unixfs","path","resolve","depth","yieldFileContent","fileSize","undefined","offset"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js"],"sourcesContent":["import extractDataFromBlock from '../../../utils/extract-data-from-block.js';\nimport validateOffsetAndLength from '../../../utils/validate-offset-and-length.js';\nimport { UnixFS } from 'ipfs-unixfs';\nimport errCode from 'err-code';\nimport * as dagPb from '@ipld/dag-pb';\nimport * as dagCbor from '@ipld/dag-cbor';\nimport * as raw from 'multiformats/codecs/raw';\nasync function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {\n  if (node instanceof Uint8Array) {\n    const buf = extractDataFromBlock(node, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += buf.length;\n    return streamPosition;\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  let file;\n  try {\n    file = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (file.data && file.data.length) {\n    const buf = extractDataFromBlock(file.data, streamPosition, start, end);\n    if (buf.length) {\n      yield buf;\n    }\n    streamPosition += file.data.length;\n  }\n  let childStart = streamPosition;\n  for (let i = 0; i < node.Links.length; i++) {\n    const childLink = node.Links[i];\n    const childEnd = streamPosition + file.blockSizes[i];\n    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {\n      const block = await blockstore.get(childLink.Hash, { signal: options.signal });\n      let child;\n      switch (childLink.Hash.code) {\n      case dagPb.code:\n        child = await dagPb.decode(block);\n        break;\n      case raw.code:\n        child = block;\n        break;\n      case dagCbor.code:\n        child = await dagCbor.decode(block);\n        break;\n      default:\n        throw Error(`Unsupported codec: ${ childLink.Hash.code }`);\n      }\n      for await (const buf of emitBytes(blockstore, child, start, end, streamPosition, options)) {\n        streamPosition += buf.length;\n        yield buf;\n      }\n    }\n    streamPosition = childEnd;\n    childStart = childEnd + 1;\n  }\n}\nconst fileContent = (cid, node, unixfs, path, resolve, depth, blockstore) => {\n  function yieldFileContent(options = {}) {\n    const fileSize = unixfs.fileSize();\n    if (fileSize === undefined) {\n      throw new Error('File was a directory');\n    }\n    const {offset, length} = validateOffsetAndLength(fileSize, options.offset, options.length);\n    const start = offset;\n    const end = offset + length;\n    return emitBytes(blockstore, node, start, end, 0, options);\n  }\n  return yieldFileContent;\n};\nexport default fileContent;"],"mappings":";;AAAA,OAAOA,oBAAoB,MAAM,2CAA2C;AAC5E,OAAOC,uBAAuB,MAAM,8CAA8C;AAClF,SAASC,MAAM,QAAQ,aAAa;AACpC,OAAOC,OAAO,MAAM,UAAU;AAC9B,OAAO,KAAKC,KAAK,MAAM,cAAc;AACrC,OAAO,KAAKC,OAAO,MAAM,gBAAgB;AACzC,OAAO,KAAKC,GAAG,MAAM,yBAAyB;AAC9C,gBAAgBC,SAAS,CAACC,UAAU,EAAEC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAEC,cAAc,GAAG,CAAC,EAAEC,OAAO,EAAE;EACnF,IAAIJ,IAAI,YAAYK,UAAU,EAAE;IAC9B,MAAMC,GAAG,GAAGf,oBAAoB,CAACS,IAAI,EAAEG,cAAc,EAAEF,KAAK,EAAEC,GAAG,CAAC;IAClE,IAAII,GAAG,CAACC,MAAM,EAAE;MACd,MAAMD,GAAG;IACX;IACAH,cAAc,IAAIG,GAAG,CAACC,MAAM;IAC5B,OAAOJ,cAAc;EACvB;EACA,IAAIH,IAAI,CAACQ,IAAI,IAAI,IAAI,EAAE;IACrB,MAAMd,OAAO,CAAC,IAAIe,KAAK,CAAC,mBAAmB,CAAC,EAAE,gBAAgB,CAAC;EACjE;EACA,IAAIC,IAAI;EACR,IAAI;IACFA,IAAI,GAAGjB,MAAM,CAACkB,SAAS,CAACX,IAAI,CAACQ,IAAI,CAAC;EACpC,CAAC,CAAC,OAAOI,GAAG,EAAE;IACZ,MAAMlB,OAAO,CAACkB,GAAG,EAAE,gBAAgB,CAAC;EACtC;EACA,IAAIF,IAAI,CAACG,IAAI,IAAIH,IAAI,CAACG,IAAI,CAACN,MAAM,EAAE;IACjC,MAAMD,GAAG,GAAGf,oBAAoB,CAACmB,IAAI,CAACG,IAAI,EAAEV,cAAc,EAAEF,KAAK,EAAEC,GAAG,CAAC;IACvE,IAAII,GAAG,CAACC,MAAM,EAAE;MACd,MAAMD,GAAG;IACX;IACAH,cAAc,IAAIO,IAAI,CAACG,IAAI,CAACN,MAAM;EACpC;EACA,IAAIO,UAAU,GAAGX,cAAc;EAC/B,KAAK,IAAIY,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGf,IAAI,CAACgB,KAAK,CAACT,MAAM,EAAEQ,CAAC,EAAE,EAAE;IAC1C,MAAME,SAAS,GAAGjB,IAAI,CAACgB,KAAK,CAACD,CAAC,CAAC;IAC/B,MAAMG,QAAQ,GAAGf,cAAc,GAAGO,IAAI,CAACS,UAAU,CAACJ,CAAC,CAAC;IACpD,IAAId,KAAK,IAAIa,UAAU,IAAIb,KAAK,GAAGiB,QAAQ,IAAIhB,GAAG,GAAGY,UAAU,IAAIZ,GAAG,IAAIgB,QAAQ,IAAIjB,KAAK,GAAGa,UAAU,IAAIZ,GAAG,GAAGgB,QAAQ,EAAE;MAC1H,MAAME,KAAK,GAAG,MAAMrB,UAAU,CAACsB,GAAG,CAACJ,SAAS,CAACK,IAAI,EAAE;QAAEC,MAAM,EAAEnB,OAAO,CAACmB;MAAO,CAAC,CAAC;MAC9E,IAAIC,KAAK;MACT,QAAQP,SAAS,CAACK,IAAI,CAACG,IAAI;QAC3B,KAAK9B,KAAK,CAAC8B,IAAI;UACbD,KAAK,GAAG,MAAM7B,KAAK,CAAC+B,MAAM,CAACN,KAAK,CAAC;UACjC;QACF,KAAKvB,GAAG,CAAC4B,IAAI;UACXD,KAAK,GAAGJ,KAAK;UACb;QACF,KAAKxB,OAAO,CAAC6B,IAAI;UACfD,KAAK,GAAG,MAAM5B,OAAO,CAAC8B,MAAM,CAACN,KAAK,CAAC;UACnC;QACF;UACE,MAAMX,KAAK,CAAE,sBAAsBQ,SAAS,CAACK,IAAI,CAACG,IAAM,EAAC,CAAC;MAAC;MAE7D,WAAW,MAAMnB,GAAG,IAAIR,SAAS,CAACC,UAAU,EAAEyB,KAAK,EAAEvB,KAAK,EAAEC,GAAG,EAAEC,cAAc,EAAEC,OAAO,CAAC,EAAE;QACzFD,cAAc,IAAIG,GAAG,CAACC,MAAM;QAC5B,MAAMD,GAAG;MACX;IACF;IACAH,cAAc,GAAGe,QAAQ;IACzBJ,UAAU,GAAGI,QAAQ,GAAG,CAAC;EAC3B;AACF;AACA,MAAMS,WAAW,GAAG,CAACC,GAAG,EAAE5B,IAAI,EAAE6B,MAAM,EAAEC,IAAI,EAAEC,OAAO,EAAEC,KAAK,EAAEjC,UAAU,KAAK;EAC3E,SAASkC,gBAAgB,CAAC7B,OAAO,GAAG,CAAC,CAAC,EAAE;IACtC,MAAM8B,QAAQ,GAAGL,MAAM,CAACK,QAAQ,EAAE;IAClC,IAAIA,QAAQ,KAAKC,SAAS,EAAE;MAC1B,MAAM,IAAI1B,KAAK,CAAC,sBAAsB,CAAC;IACzC;IACA,MAAM;MAAC2B,MAAM;MAAE7B;IAAM,CAAC,GAAGf,uBAAuB,CAAC0C,QAAQ,EAAE9B,OAAO,CAACgC,MAAM,EAAEhC,OAAO,CAACG,MAAM,CAAC;IAC1F,MAAMN,KAAK,GAAGmC,MAAM;IACpB,MAAMlC,GAAG,GAAGkC,MAAM,GAAG7B,MAAM;IAC3B,OAAOT,SAAS,CAACC,UAAU,EAAEC,IAAI,EAAEC,KAAK,EAAEC,GAAG,EAAE,CAAC,EAAEE,OAAO,CAAC;EAC5D;EACA,OAAO6B,gBAAgB;AACzB,CAAC;AACD,eAAeN,WAAW"},"metadata":{},"sourceType":"module","externalDependencies":[]}