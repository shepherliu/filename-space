{"ast":null,"code":"import \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport \"core-js/modules/es.array.push.js\";\nimport varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${block.version}\"`);\n    }\n    throw new Error(`Invalid CAR version: ${block.version}`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${version})`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\nexport async function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {\n    cid,\n    blockLength\n  } = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {\n    cid,\n    length,\n    blockLength\n  } = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}","map":{"version":3,"names":["varint","CID","Digest","decode","decodeDagCbor","CIDV0_BYTES","SHA2_256","LENGTH","DAG_PB","readVarint","reader","bytes","upTo","i","seek","readHeader","length","Error","header","exactly","block","Array","isArray","version","roots","Object","keys","filter","p","readMultihash","codeLength","subarray","lengthLength","mhLength","multihash","readCid","first","create","codec","readBlockHead","start","pos","cid","blockLength","readBlock","readBlockIndex","offset","index","blockOffset","createDecoder","headerPromise","blocks","blocksIndex","bytesReader","Math","min","chunkReader","readChunk","have","currentChunk","Uint8Array","read","bufa","chunk","push","reduce","c","off","b","set","asyncIterableReader","asyncIterable","iterator","Symbol","asyncIterator","next","done","value"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/@ipld/car/esm/lib/decoder.js"],"sourcesContent":["import varint from 'varint';\nimport { CID } from 'multiformats/cid';\nimport * as Digest from 'multiformats/hashes/digest';\nimport { decode as decodeDagCbor } from '@ipld/dag-cbor';\nconst CIDV0_BYTES = {\n  SHA2_256: 18,\n  LENGTH: 32,\n  DAG_PB: 112\n};\nasync function readVarint(reader) {\n  const bytes = await reader.upTo(8);\n  const i = varint.decode(bytes);\n  reader.seek(varint.decode.bytes);\n  return i;\n}\nexport async function readHeader(reader) {\n  const length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR header (zero length)');\n  }\n  const header = await reader.exactly(length);\n  reader.seek(length);\n  const block = decodeDagCbor(header);\n  if (block == null || Array.isArray(block) || typeof block !== 'object') {\n    throw new Error('Invalid CAR header format');\n  }\n  if (block.version !== 1) {\n    if (typeof block.version === 'string') {\n      throw new Error(`Invalid CAR version: \"${ block.version }\"`);\n    }\n    throw new Error(`Invalid CAR version: ${ block.version }`);\n  }\n  if (!Array.isArray(block.roots)) {\n    throw new Error('Invalid CAR header format');\n  }\n  if (Object.keys(block).filter(p => p !== 'roots' && p !== 'version').length) {\n    throw new Error('Invalid CAR header format');\n  }\n  return block;\n}\nasync function readMultihash(reader) {\n  const bytes = await reader.upTo(8);\n  varint.decode(bytes);\n  const codeLength = varint.decode.bytes;\n  const length = varint.decode(bytes.subarray(varint.decode.bytes));\n  const lengthLength = varint.decode.bytes;\n  const mhLength = codeLength + lengthLength + length;\n  const multihash = await reader.exactly(mhLength);\n  reader.seek(mhLength);\n  return multihash;\n}\nasync function readCid(reader) {\n  const first = await reader.exactly(2);\n  if (first[0] === CIDV0_BYTES.SHA2_256 && first[1] === CIDV0_BYTES.LENGTH) {\n    const bytes = await reader.exactly(34);\n    reader.seek(34);\n    const multihash = Digest.decode(bytes);\n    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash);\n  }\n  const version = await readVarint(reader);\n  if (version !== 1) {\n    throw new Error(`Unexpected CID version (${ version })`);\n  }\n  const codec = await readVarint(reader);\n  const bytes = await readMultihash(reader);\n  const multihash = Digest.decode(bytes);\n  return CID.create(version, codec, multihash);\n}\nexport async function readBlockHead(reader) {\n  const start = reader.pos;\n  let length = await readVarint(reader);\n  if (length === 0) {\n    throw new Error('Invalid CAR section (zero length)');\n  }\n  length += reader.pos - start;\n  const cid = await readCid(reader);\n  const blockLength = length - (reader.pos - start);\n  return {\n    cid,\n    length,\n    blockLength\n  };\n}\nasync function readBlock(reader) {\n  const {cid, blockLength} = await readBlockHead(reader);\n  const bytes = await reader.exactly(blockLength);\n  reader.seek(blockLength);\n  return {\n    bytes,\n    cid\n  };\n}\nasync function readBlockIndex(reader) {\n  const offset = reader.pos;\n  const {cid, length, blockLength} = await readBlockHead(reader);\n  const index = {\n    cid,\n    length,\n    blockLength,\n    offset,\n    blockOffset: reader.pos\n  };\n  reader.seek(index.blockLength);\n  return index;\n}\nexport function createDecoder(reader) {\n  const headerPromise = readHeader(reader);\n  return {\n    header: () => headerPromise,\n    async *blocks() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlock(reader);\n      }\n    },\n    async *blocksIndex() {\n      await headerPromise;\n      while ((await reader.upTo(8)).length > 0) {\n        yield await readBlockIndex(reader);\n      }\n    }\n  };\n}\nexport function bytesReader(bytes) {\n  let pos = 0;\n  return {\n    async upTo(length) {\n      return bytes.subarray(pos, pos + Math.min(length, bytes.length - pos));\n    },\n    async exactly(length) {\n      if (length > bytes.length - pos) {\n        throw new Error('Unexpected end of data');\n      }\n      return bytes.subarray(pos, pos + length);\n    },\n    seek(length) {\n      pos += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function chunkReader(readChunk) {\n  let pos = 0;\n  let have = 0;\n  let offset = 0;\n  let currentChunk = new Uint8Array(0);\n  const read = async length => {\n    have = currentChunk.length - offset;\n    const bufa = [currentChunk.subarray(offset)];\n    while (have < length) {\n      const chunk = await readChunk();\n      if (chunk == null) {\n        break;\n      }\n      if (have < 0) {\n        if (chunk.length > have) {\n          bufa.push(chunk.subarray(-have));\n        }\n      } else {\n        bufa.push(chunk);\n      }\n      have += chunk.length;\n    }\n    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));\n    let off = 0;\n    for (const b of bufa) {\n      currentChunk.set(b, off);\n      off += b.length;\n    }\n    offset = 0;\n  };\n  return {\n    async upTo(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length));\n    },\n    async exactly(length) {\n      if (currentChunk.length - offset < length) {\n        await read(length);\n      }\n      if (currentChunk.length - offset < length) {\n        throw new Error('Unexpected end of data');\n      }\n      return currentChunk.subarray(offset, offset + length);\n    },\n    seek(length) {\n      pos += length;\n      offset += length;\n    },\n    get pos() {\n      return pos;\n    }\n  };\n}\nexport function asyncIterableReader(asyncIterable) {\n  const iterator = asyncIterable[Symbol.asyncIterator]();\n  async function readChunk() {\n    const next = await iterator.next();\n    if (next.done) {\n      return null;\n    }\n    return next.value;\n  }\n  return chunkReader(readChunk);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}