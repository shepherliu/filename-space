{"ast":null,"code":"'use strict';\n\n// @ts-ignore\nrequire(\"core-js/modules/es.array.push.js\");\nconst SparseArray = require('sparse-array');\nconst {\n  fromString: uint8ArrayFromString\n} = require('uint8arrays/from-string');\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor(options, parent, posAtParent = 0) {\n    this._options = options;\n    this._popCount = 0;\n    this._parent = parent;\n    this._posAtParent = posAtParent;\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray();\n\n    /** @type {string | null} */\n    this.key = null;\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put(key, value) {\n    const place = await this._findNewBucketAndPos(key);\n    await place.bucket._putAt(place, key, value);\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get(key) {\n    const child = await this._findChild(key);\n    if (child) {\n      return child.value;\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del(key) {\n    const place = await this._findPlace(key);\n    const child = place.bucket._at(place.pos);\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos);\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount() {\n    const children = this._children.compactArray();\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount();\n      }\n      return acc + 1;\n    }, 0);\n  }\n  childrenCount() {\n    return this._children.length;\n  }\n  onlyChild() {\n    return this._children.get(0);\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  *eachLeafSeries() {\n    const children = this._children.compactArray();\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield* child.eachLeafSeries();\n      } else {\n        yield child;\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return [];\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize(map, reduce) {\n    /** @type {T[]} */\n    const acc = [];\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce));\n        } else {\n          acc.push(map(child, index));\n        }\n      }\n      return acc;\n    }, acc));\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform(asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce);\n  }\n  toJSON() {\n    return this.serialize(mapNode, reduceNodes);\n  }\n  prettyPrint() {\n    return JSON.stringify(this.toJSON(), null, '  ');\n  }\n  tableSize() {\n    return Math.pow(2, this._options.bits);\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild(key) {\n    const result = await this._findPlace(key);\n    const child = result.bucket._at(result.pos);\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined;\n    }\n    if (child && child.key === key) {\n      return child;\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace(key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key);\n    const index = await hashValue.take(this._options.bits);\n    const child = this._children.get(index);\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue);\n    }\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    };\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos(key) {\n    const place = await this._findPlace(key);\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos);\n      place.bucket._putObjectAt(place.pos, bucket);\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash);\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);\n      return bucket._findNewBucketAndPos(place.hash);\n    }\n\n    // no conflict, we found the place\n    return place;\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt(place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    });\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt(pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++;\n    }\n    this._children.set(pos, object);\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt(pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position');\n    }\n    if (this._children.get(pos)) {\n      this._popCount--;\n    }\n    this._children.unset(pos);\n    this._level();\n  }\n  _level() {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists);\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash;\n          hash.untake(this._options.bits);\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          };\n          this._parent._putAt(place, onlyChild.key, onlyChild.value);\n        }\n      } else {\n        this._parent._delAt(this._posAtParent);\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at(index) {\n    return this._children.get(index);\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists(o) {\n  return Boolean(o);\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode(node, index) {\n  return node.key;\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes(nodes) {\n  return nodes;\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket(bucket, asyncMap, asyncReduce) {\n  const output = [];\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce);\n    } else {\n      const mappedChildren = await asyncMap(child);\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      });\n    }\n  }\n  return asyncReduce(output);\n}\nmodule.exports = Bucket;","map":{"version":3,"names":["SparseArray","require","fromString","uint8ArrayFromString","Bucket","constructor","options","parent","posAtParent","_options","_popCount","_parent","_posAtParent","_children","key","put","value","place","_findNewBucketAndPos","bucket","_putAt","get","child","_findChild","del","_findPlace","_at","pos","_delAt","leafCount","children","compactArray","reduce","acc","childrenCount","length","onlyChild","eachLeafSeries","serialize","map","index","push","asyncTransform","asyncMap","asyncReduce","asyncTransformBucket","toJSON","mapNode","reduceNodes","prettyPrint","JSON","stringify","tableSize","Math","pow","bits","result","undefined","hashValue","hash","take","existingChild","_putObjectAt","newPlace","object","set","Error","unset","_level","find","exists","untake","o","Boolean","node","nodes","output","mappedChildren","bitField","module","exports"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/hamt-sharding/src/bucket.js"],"sourcesContent":["'use strict'\n\n// @ts-ignore\nconst SparseArray = require('sparse-array')\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\n\n/**\n * @typedef {import('./consumable-hash').InfiniteHash} InfiniteHash\n * @typedef {import('../').UserBucketOptions} UserBucketOptions\n */\n\n/**\n * @template V\n * @typedef {object} BucketChild<V>\n * @property {string} key\n * @property {V} value\n * @property {InfiniteHash} hash\n */\n\n/**\n * @template B\n *\n * @typedef {object} SA<B>\n * @property {number} length\n * @property {() => B[]} compactArray\n * @property {(i: number) => B} get\n * @property {(i: number, value: B) => void} set\n * @property {<A> (fn: (acc: A, curr: B, index: number) => A, initial: A) => B} reduce\n * @property {(fn: (item: B) => boolean) => B | undefined} find\n * @property {() => number[]} bitField\n * @property {(i: number) => void} unset\n */\n\n/**\n * @template T\n *\n * @typedef {object} BucketPosition<T>\n * @property {Bucket<T>} bucket\n * @property {number} pos\n * @property {InfiniteHash} hash\n * @property {BucketChild<T>} [existingChild]\n */\n\n/**\n * @typedef {object} BucketOptions\n * @property {number} bits\n * @property {(value: Uint8Array | InfiniteHash) => InfiniteHash} hash\n */\n\n/**\n * @template T\n */\nclass Bucket {\n  /**\n   * @param {BucketOptions} options\n   * @param {Bucket<T>} [parent]\n   * @param {number} [posAtParent=0]\n   */\n  constructor (options, parent, posAtParent = 0) {\n    this._options = options\n    this._popCount = 0\n    this._parent = parent\n    this._posAtParent = posAtParent\n\n    /** @type {SA<Bucket<T> | BucketChild<T>>} */\n    this._children = new SparseArray()\n\n    /** @type {string | null} */\n    this.key = null\n  }\n\n  /**\n   * @param {string} key\n   * @param {T} value\n   */\n  async put (key, value) {\n    const place = await this._findNewBucketAndPos(key)\n\n    await place.bucket._putAt(place, key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  async get (key) {\n    const child = await this._findChild(key)\n\n    if (child) {\n      return child.value\n    }\n  }\n\n  /**\n   * @param {string} key\n   */\n  async del (key) {\n    const place = await this._findPlace(key)\n    const child = place.bucket._at(place.pos)\n\n    if (child && child.key === key) {\n      place.bucket._delAt(place.pos)\n    }\n  }\n\n  /**\n   * @returns {number}\n   */\n  leafCount () {\n    const children = this._children.compactArray()\n\n    return children.reduce((acc, child) => {\n      if (child instanceof Bucket) {\n        return acc + child.leafCount()\n      }\n\n      return acc + 1\n    }, 0)\n  }\n\n  childrenCount () {\n    return this._children.length\n  }\n\n  onlyChild () {\n    return this._children.get(0)\n  }\n\n  /**\n   * @returns {Iterable<BucketChild<T>>}\n   */\n  * eachLeafSeries () {\n    const children = this._children.compactArray()\n\n    for (const child of children) {\n      if (child instanceof Bucket) {\n        yield * child.eachLeafSeries()\n      } else {\n        yield child\n      }\n    }\n\n    // this is necessary because tsc requires a @return annotation as it\n    // can't derive a return type due to the recursion, and eslint requires\n    // a return statement when there is a @return annotation\n    return []\n  }\n\n  /**\n   * @param {(value: BucketChild<T>, index: number) => T} map\n   * @param {(reduced: any) => any} reduce\n   */\n  serialize (map, reduce) {\n    /** @type {T[]} */\n    const acc = []\n    // serialize to a custom non-sparse representation\n    return reduce(this._children.reduce((acc, child, index) => {\n      if (child) {\n        if (child instanceof Bucket) {\n          acc.push(child.serialize(map, reduce))\n        } else {\n          acc.push(map(child, index))\n        }\n      }\n      return acc\n    }, acc))\n  }\n\n  /**\n   * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n   * @param {(reduced: any) => Promise<any>} asyncReduce\n   */\n  asyncTransform (asyncMap, asyncReduce) {\n    return asyncTransformBucket(this, asyncMap, asyncReduce)\n  }\n\n  toJSON () {\n    return this.serialize(mapNode, reduceNodes)\n  }\n\n  prettyPrint () {\n    return JSON.stringify(this.toJSON(), null, '  ')\n  }\n\n  tableSize () {\n    return Math.pow(2, this._options.bits)\n  }\n\n  /**\n   * @param {string} key\n   * @returns {Promise<BucketChild<T> | undefined>}\n   */\n  async _findChild (key) {\n    const result = await this._findPlace(key)\n    const child = result.bucket._at(result.pos)\n\n    if (child instanceof Bucket) {\n      // should not be possible, this._findPlace should always\n      // return a location for a child, not a bucket\n      return undefined\n    }\n\n    if (child && child.key === key) {\n      return child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findPlace (key) {\n    const hashValue = this._options.hash(typeof key === 'string' ? uint8ArrayFromString(key) : key)\n    const index = await hashValue.take(this._options.bits)\n\n    const child = this._children.get(index)\n\n    if (child instanceof Bucket) {\n      return child._findPlace(hashValue)\n    }\n\n    return {\n      bucket: this,\n      pos: index,\n      hash: hashValue,\n      existingChild: child\n    }\n  }\n\n  /**\n   * @param {string | InfiniteHash} key\n   * @returns {Promise<BucketPosition<T>>}\n   */\n  async _findNewBucketAndPos (key) {\n    const place = await this._findPlace(key)\n\n    if (place.existingChild && place.existingChild.key !== key) {\n      // conflict\n      const bucket = new Bucket(this._options, place.bucket, place.pos)\n      place.bucket._putObjectAt(place.pos, bucket)\n\n      // put the previous value\n      const newPlace = await bucket._findPlace(place.existingChild.hash)\n      newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value)\n\n      return bucket._findNewBucketAndPos(place.hash)\n    }\n\n    // no conflict, we found the place\n    return place\n  }\n\n  /**\n   * @param {BucketPosition<T>} place\n   * @param {string} key\n   * @param {T} value\n   */\n  _putAt (place, key, value) {\n    this._putObjectAt(place.pos, {\n      key: key,\n      value: value,\n      hash: place.hash\n    })\n  }\n\n  /**\n   * @param {number} pos\n   * @param {Bucket<T> | BucketChild<T>} object\n   */\n  _putObjectAt (pos, object) {\n    if (!this._children.get(pos)) {\n      this._popCount++\n    }\n    this._children.set(pos, object)\n  }\n\n  /**\n   * @param {number} pos\n   */\n  _delAt (pos) {\n    if (pos === -1) {\n      throw new Error('Invalid position')\n    }\n\n    if (this._children.get(pos)) {\n      this._popCount--\n    }\n    this._children.unset(pos)\n    this._level()\n  }\n\n  _level () {\n    if (this._parent && this._popCount <= 1) {\n      if (this._popCount === 1) {\n        // remove myself from parent, replacing me with my only child\n        const onlyChild = this._children.find(exists)\n\n        if (onlyChild && !(onlyChild instanceof Bucket)) {\n          const hash = onlyChild.hash\n          hash.untake(this._options.bits)\n          const place = {\n            pos: this._posAtParent,\n            hash: hash,\n            bucket: this._parent\n          }\n          this._parent._putAt(place, onlyChild.key, onlyChild.value)\n        }\n      } else {\n        this._parent._delAt(this._posAtParent)\n      }\n    }\n  }\n\n  /**\n   * @param {number} index\n   * @returns {BucketChild<T> | Bucket<T> | undefined}\n   */\n  _at (index) {\n    return this._children.get(index)\n  }\n}\n\n/**\n * @param {any} o\n */\nfunction exists (o) {\n  return Boolean(o)\n}\n\n/**\n *\n * @param {*} node\n * @param {number} index\n */\nfunction mapNode (node, index) {\n  return node.key\n}\n\n/**\n * @param {*} nodes\n */\nfunction reduceNodes (nodes) {\n  return nodes\n}\n\n/**\n * @template T\n *\n * @param {Bucket<T>} bucket\n * @param {(value: BucketChild<T>) => Promise<T[]>} asyncMap\n * @param {(reduced: any) => Promise<any>} asyncReduce\n */\nasync function asyncTransformBucket (bucket, asyncMap, asyncReduce) {\n  const output = []\n\n  for (const child of bucket._children.compactArray()) {\n    if (child instanceof Bucket) {\n      await asyncTransformBucket(child, asyncMap, asyncReduce)\n    } else {\n      const mappedChildren = await asyncMap(child)\n\n      output.push({\n        bitField: bucket._children.bitField(),\n        children: mappedChildren\n      })\n    }\n  }\n\n  return asyncReduce(output)\n}\n\nmodule.exports = Bucket\n"],"mappings":"AAAA,YAAY;;AAEZ;AAAA;AACA,MAAMA,WAAW,GAAGC,OAAO,CAAC,cAAc,CAAC;AAC3C,MAAM;EAAEC,UAAU,EAAEC;AAAqB,CAAC,GAAGF,OAAO,CAAC,yBAAyB,CAAC;;AAE/E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAMG,MAAM,CAAC;EACX;AACF;AACA;AACA;AACA;EACEC,WAAW,CAAEC,OAAO,EAAEC,MAAM,EAAEC,WAAW,GAAG,CAAC,EAAE;IAC7C,IAAI,CAACC,QAAQ,GAAGH,OAAO;IACvB,IAAI,CAACI,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,OAAO,GAAGJ,MAAM;IACrB,IAAI,CAACK,YAAY,GAAGJ,WAAW;;IAE/B;IACA,IAAI,CAACK,SAAS,GAAG,IAAIb,WAAW,EAAE;;IAElC;IACA,IAAI,CAACc,GAAG,GAAG,IAAI;EACjB;;EAEA;AACF;AACA;AACA;EACE,MAAMC,GAAG,CAAED,GAAG,EAAEE,KAAK,EAAE;IACrB,MAAMC,KAAK,GAAG,MAAM,IAAI,CAACC,oBAAoB,CAACJ,GAAG,CAAC;IAElD,MAAMG,KAAK,CAACE,MAAM,CAACC,MAAM,CAACH,KAAK,EAAEH,GAAG,EAAEE,KAAK,CAAC;EAC9C;;EAEA;AACF;AACA;EACE,MAAMK,GAAG,CAAEP,GAAG,EAAE;IACd,MAAMQ,KAAK,GAAG,MAAM,IAAI,CAACC,UAAU,CAACT,GAAG,CAAC;IAExC,IAAIQ,KAAK,EAAE;MACT,OAAOA,KAAK,CAACN,KAAK;IACpB;EACF;;EAEA;AACF;AACA;EACE,MAAMQ,GAAG,CAAEV,GAAG,EAAE;IACd,MAAMG,KAAK,GAAG,MAAM,IAAI,CAACQ,UAAU,CAACX,GAAG,CAAC;IACxC,MAAMQ,KAAK,GAAGL,KAAK,CAACE,MAAM,CAACO,GAAG,CAACT,KAAK,CAACU,GAAG,CAAC;IAEzC,IAAIL,KAAK,IAAIA,KAAK,CAACR,GAAG,KAAKA,GAAG,EAAE;MAC9BG,KAAK,CAACE,MAAM,CAACS,MAAM,CAACX,KAAK,CAACU,GAAG,CAAC;IAChC;EACF;;EAEA;AACF;AACA;EACEE,SAAS,GAAI;IACX,MAAMC,QAAQ,GAAG,IAAI,CAACjB,SAAS,CAACkB,YAAY,EAAE;IAE9C,OAAOD,QAAQ,CAACE,MAAM,CAAC,CAACC,GAAG,EAAEX,KAAK,KAAK;MACrC,IAAIA,KAAK,YAAYlB,MAAM,EAAE;QAC3B,OAAO6B,GAAG,GAAGX,KAAK,CAACO,SAAS,EAAE;MAChC;MAEA,OAAOI,GAAG,GAAG,CAAC;IAChB,CAAC,EAAE,CAAC,CAAC;EACP;EAEAC,aAAa,GAAI;IACf,OAAO,IAAI,CAACrB,SAAS,CAACsB,MAAM;EAC9B;EAEAC,SAAS,GAAI;IACX,OAAO,IAAI,CAACvB,SAAS,CAACQ,GAAG,CAAC,CAAC,CAAC;EAC9B;;EAEA;AACF;AACA;EACE,CAAEgB,cAAc,GAAI;IAClB,MAAMP,QAAQ,GAAG,IAAI,CAACjB,SAAS,CAACkB,YAAY,EAAE;IAE9C,KAAK,MAAMT,KAAK,IAAIQ,QAAQ,EAAE;MAC5B,IAAIR,KAAK,YAAYlB,MAAM,EAAE;QAC3B,OAAQkB,KAAK,CAACe,cAAc,EAAE;MAChC,CAAC,MAAM;QACL,MAAMf,KAAK;MACb;IACF;;IAEA;IACA;IACA;IACA,OAAO,EAAE;EACX;;EAEA;AACF;AACA;AACA;EACEgB,SAAS,CAAEC,GAAG,EAAEP,MAAM,EAAE;IACtB;IACA,MAAMC,GAAG,GAAG,EAAE;IACd;IACA,OAAOD,MAAM,CAAC,IAAI,CAACnB,SAAS,CAACmB,MAAM,CAAC,CAACC,GAAG,EAAEX,KAAK,EAAEkB,KAAK,KAAK;MACzD,IAAIlB,KAAK,EAAE;QACT,IAAIA,KAAK,YAAYlB,MAAM,EAAE;UAC3B6B,GAAG,CAACQ,IAAI,CAACnB,KAAK,CAACgB,SAAS,CAACC,GAAG,EAAEP,MAAM,CAAC,CAAC;QACxC,CAAC,MAAM;UACLC,GAAG,CAACQ,IAAI,CAACF,GAAG,CAACjB,KAAK,EAAEkB,KAAK,CAAC,CAAC;QAC7B;MACF;MACA,OAAOP,GAAG;IACZ,CAAC,EAAEA,GAAG,CAAC,CAAC;EACV;;EAEA;AACF;AACA;AACA;EACES,cAAc,CAAEC,QAAQ,EAAEC,WAAW,EAAE;IACrC,OAAOC,oBAAoB,CAAC,IAAI,EAAEF,QAAQ,EAAEC,WAAW,CAAC;EAC1D;EAEAE,MAAM,GAAI;IACR,OAAO,IAAI,CAACR,SAAS,CAACS,OAAO,EAAEC,WAAW,CAAC;EAC7C;EAEAC,WAAW,GAAI;IACb,OAAOC,IAAI,CAACC,SAAS,CAAC,IAAI,CAACL,MAAM,EAAE,EAAE,IAAI,EAAE,IAAI,CAAC;EAClD;EAEAM,SAAS,GAAI;IACX,OAAOC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC7C,QAAQ,CAAC8C,IAAI,CAAC;EACxC;;EAEA;AACF;AACA;AACA;EACE,MAAMhC,UAAU,CAAET,GAAG,EAAE;IACrB,MAAM0C,MAAM,GAAG,MAAM,IAAI,CAAC/B,UAAU,CAACX,GAAG,CAAC;IACzC,MAAMQ,KAAK,GAAGkC,MAAM,CAACrC,MAAM,CAACO,GAAG,CAAC8B,MAAM,CAAC7B,GAAG,CAAC;IAE3C,IAAIL,KAAK,YAAYlB,MAAM,EAAE;MAC3B;MACA;MACA,OAAOqD,SAAS;IAClB;IAEA,IAAInC,KAAK,IAAIA,KAAK,CAACR,GAAG,KAAKA,GAAG,EAAE;MAC9B,OAAOQ,KAAK;IACd;EACF;;EAEA;AACF;AACA;AACA;EACE,MAAMG,UAAU,CAAEX,GAAG,EAAE;IACrB,MAAM4C,SAAS,GAAG,IAAI,CAACjD,QAAQ,CAACkD,IAAI,CAAC,OAAO7C,GAAG,KAAK,QAAQ,GAAGX,oBAAoB,CAACW,GAAG,CAAC,GAAGA,GAAG,CAAC;IAC/F,MAAM0B,KAAK,GAAG,MAAMkB,SAAS,CAACE,IAAI,CAAC,IAAI,CAACnD,QAAQ,CAAC8C,IAAI,CAAC;IAEtD,MAAMjC,KAAK,GAAG,IAAI,CAACT,SAAS,CAACQ,GAAG,CAACmB,KAAK,CAAC;IAEvC,IAAIlB,KAAK,YAAYlB,MAAM,EAAE;MAC3B,OAAOkB,KAAK,CAACG,UAAU,CAACiC,SAAS,CAAC;IACpC;IAEA,OAAO;MACLvC,MAAM,EAAE,IAAI;MACZQ,GAAG,EAAEa,KAAK;MACVmB,IAAI,EAAED,SAAS;MACfG,aAAa,EAAEvC;IACjB,CAAC;EACH;;EAEA;AACF;AACA;AACA;EACE,MAAMJ,oBAAoB,CAAEJ,GAAG,EAAE;IAC/B,MAAMG,KAAK,GAAG,MAAM,IAAI,CAACQ,UAAU,CAACX,GAAG,CAAC;IAExC,IAAIG,KAAK,CAAC4C,aAAa,IAAI5C,KAAK,CAAC4C,aAAa,CAAC/C,GAAG,KAAKA,GAAG,EAAE;MAC1D;MACA,MAAMK,MAAM,GAAG,IAAIf,MAAM,CAAC,IAAI,CAACK,QAAQ,EAAEQ,KAAK,CAACE,MAAM,EAAEF,KAAK,CAACU,GAAG,CAAC;MACjEV,KAAK,CAACE,MAAM,CAAC2C,YAAY,CAAC7C,KAAK,CAACU,GAAG,EAAER,MAAM,CAAC;;MAE5C;MACA,MAAM4C,QAAQ,GAAG,MAAM5C,MAAM,CAACM,UAAU,CAACR,KAAK,CAAC4C,aAAa,CAACF,IAAI,CAAC;MAClEI,QAAQ,CAAC5C,MAAM,CAACC,MAAM,CAAC2C,QAAQ,EAAE9C,KAAK,CAAC4C,aAAa,CAAC/C,GAAG,EAAEG,KAAK,CAAC4C,aAAa,CAAC7C,KAAK,CAAC;MAEpF,OAAOG,MAAM,CAACD,oBAAoB,CAACD,KAAK,CAAC0C,IAAI,CAAC;IAChD;;IAEA;IACA,OAAO1C,KAAK;EACd;;EAEA;AACF;AACA;AACA;AACA;EACEG,MAAM,CAAEH,KAAK,EAAEH,GAAG,EAAEE,KAAK,EAAE;IACzB,IAAI,CAAC8C,YAAY,CAAC7C,KAAK,CAACU,GAAG,EAAE;MAC3Bb,GAAG,EAAEA,GAAG;MACRE,KAAK,EAAEA,KAAK;MACZ2C,IAAI,EAAE1C,KAAK,CAAC0C;IACd,CAAC,CAAC;EACJ;;EAEA;AACF;AACA;AACA;EACEG,YAAY,CAAEnC,GAAG,EAAEqC,MAAM,EAAE;IACzB,IAAI,CAAC,IAAI,CAACnD,SAAS,CAACQ,GAAG,CAACM,GAAG,CAAC,EAAE;MAC5B,IAAI,CAACjB,SAAS,EAAE;IAClB;IACA,IAAI,CAACG,SAAS,CAACoD,GAAG,CAACtC,GAAG,EAAEqC,MAAM,CAAC;EACjC;;EAEA;AACF;AACA;EACEpC,MAAM,CAAED,GAAG,EAAE;IACX,IAAIA,GAAG,KAAK,CAAC,CAAC,EAAE;MACd,MAAM,IAAIuC,KAAK,CAAC,kBAAkB,CAAC;IACrC;IAEA,IAAI,IAAI,CAACrD,SAAS,CAACQ,GAAG,CAACM,GAAG,CAAC,EAAE;MAC3B,IAAI,CAACjB,SAAS,EAAE;IAClB;IACA,IAAI,CAACG,SAAS,CAACsD,KAAK,CAACxC,GAAG,CAAC;IACzB,IAAI,CAACyC,MAAM,EAAE;EACf;EAEAA,MAAM,GAAI;IACR,IAAI,IAAI,CAACzD,OAAO,IAAI,IAAI,CAACD,SAAS,IAAI,CAAC,EAAE;MACvC,IAAI,IAAI,CAACA,SAAS,KAAK,CAAC,EAAE;QACxB;QACA,MAAM0B,SAAS,GAAG,IAAI,CAACvB,SAAS,CAACwD,IAAI,CAACC,MAAM,CAAC;QAE7C,IAAIlC,SAAS,IAAI,EAAEA,SAAS,YAAYhC,MAAM,CAAC,EAAE;UAC/C,MAAMuD,IAAI,GAAGvB,SAAS,CAACuB,IAAI;UAC3BA,IAAI,CAACY,MAAM,CAAC,IAAI,CAAC9D,QAAQ,CAAC8C,IAAI,CAAC;UAC/B,MAAMtC,KAAK,GAAG;YACZU,GAAG,EAAE,IAAI,CAACf,YAAY;YACtB+C,IAAI,EAAEA,IAAI;YACVxC,MAAM,EAAE,IAAI,CAACR;UACf,CAAC;UACD,IAAI,CAACA,OAAO,CAACS,MAAM,CAACH,KAAK,EAAEmB,SAAS,CAACtB,GAAG,EAAEsB,SAAS,CAACpB,KAAK,CAAC;QAC5D;MACF,CAAC,MAAM;QACL,IAAI,CAACL,OAAO,CAACiB,MAAM,CAAC,IAAI,CAAChB,YAAY,CAAC;MACxC;IACF;EACF;;EAEA;AACF;AACA;AACA;EACEc,GAAG,CAAEc,KAAK,EAAE;IACV,OAAO,IAAI,CAAC3B,SAAS,CAACQ,GAAG,CAACmB,KAAK,CAAC;EAClC;AACF;;AAEA;AACA;AACA;AACA,SAAS8B,MAAM,CAAEE,CAAC,EAAE;EAClB,OAAOC,OAAO,CAACD,CAAC,CAAC;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASzB,OAAO,CAAE2B,IAAI,EAAElC,KAAK,EAAE;EAC7B,OAAOkC,IAAI,CAAC5D,GAAG;AACjB;;AAEA;AACA;AACA;AACA,SAASkC,WAAW,CAAE2B,KAAK,EAAE;EAC3B,OAAOA,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe9B,oBAAoB,CAAE1B,MAAM,EAAEwB,QAAQ,EAAEC,WAAW,EAAE;EAClE,MAAMgC,MAAM,GAAG,EAAE;EAEjB,KAAK,MAAMtD,KAAK,IAAIH,MAAM,CAACN,SAAS,CAACkB,YAAY,EAAE,EAAE;IACnD,IAAIT,KAAK,YAAYlB,MAAM,EAAE;MAC3B,MAAMyC,oBAAoB,CAACvB,KAAK,EAAEqB,QAAQ,EAAEC,WAAW,CAAC;IAC1D,CAAC,MAAM;MACL,MAAMiC,cAAc,GAAG,MAAMlC,QAAQ,CAACrB,KAAK,CAAC;MAE5CsD,MAAM,CAACnC,IAAI,CAAC;QACVqC,QAAQ,EAAE3D,MAAM,CAACN,SAAS,CAACiE,QAAQ,EAAE;QACrChD,QAAQ,EAAE+C;MACZ,CAAC,CAAC;IACJ;EACF;EAEA,OAAOjC,WAAW,CAACgC,MAAM,CAAC;AAC5B;AAEAG,MAAM,CAACC,OAAO,GAAG5E,MAAM"},"metadata":{},"sourceType":"script","externalDependencies":[]}