{"ast":null,"code":"import toIterable from 'browser-readablestream-to-it';\nimport { CarBlockIterator } from '@ipld/car/iterator';\nimport { recursive as unixFsExporter } from 'ipfs-unixfs-exporter';\nimport { VerifyingGetOnlyBlockStore } from \"./utils/verifying-get-only-blockstore.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\n// Export unixfs entries from car file\nexport async function* unpack(carReader, roots) {\n  const verifyingBlockService = VerifyingGetOnlyBlockStore.fromCarReader(carReader);\n  if (!roots || roots.length === 0) {\n    roots = await carReader.getRoots();\n  }\n  for (const root of roots) {\n    yield* unixFsExporter(root, verifyingBlockService, {/* options */});\n  }\n}\nexport async function* unpackStream(readable, {\n  roots,\n  blockstore: userBlockstore\n} = {}) {\n  const carIterator = await CarBlockIterator.fromIterable(asAsyncIterable(readable));\n  const blockstore = userBlockstore || new MemoryBlockStore();\n  for await (const block of carIterator) {\n    await blockstore.put(block.cid, block.bytes);\n  }\n  const verifyingBlockStore = VerifyingGetOnlyBlockStore.fromBlockstore(blockstore);\n  if (!roots || roots.length === 0) {\n    roots = await carIterator.getRoots();\n  }\n  for (const root of roots) {\n    yield* unixFsExporter(root, verifyingBlockStore);\n  }\n}\n/**\n * Upgrade a ReadableStream to an AsyncIterable if it isn't already\n *\n * ReadableStream (e.g res.body) is asyncIterable in node, but not in chrome, yet.\n * see: https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n */\nfunction asAsyncIterable(readable) {\n  // @ts-ignore how to convince tsc that we are checking the type here?\n  return Symbol.asyncIterator in readable ? readable : toIterable(readable);\n}","map":{"version":3,"names":["toIterable","CarBlockIterator","recursive","unixFsExporter","VerifyingGetOnlyBlockStore","MemoryBlockStore","unpack","carReader","roots","verifyingBlockService","fromCarReader","length","getRoots","root","unpackStream","readable","blockstore","userBlockstore","carIterator","fromIterable","asAsyncIterable","block","put","cid","bytes","verifyingBlockStore","fromBlockstore","Symbol","asyncIterator"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/ipfs-car/dist/esm/unpack/index.js"],"sourcesContent":["import toIterable from 'browser-readablestream-to-it';\nimport { CarBlockIterator } from '@ipld/car/iterator';\nimport { recursive as unixFsExporter } from 'ipfs-unixfs-exporter';\nimport { VerifyingGetOnlyBlockStore } from \"./utils/verifying-get-only-blockstore.js\";\nimport { MemoryBlockStore } from \"../blockstore/memory.js\";\n// Export unixfs entries from car file\nexport async function* unpack(carReader, roots) {\n    const verifyingBlockService = VerifyingGetOnlyBlockStore.fromCarReader(carReader);\n    if (!roots || roots.length === 0) {\n        roots = await carReader.getRoots();\n    }\n    for (const root of roots) {\n        yield* unixFsExporter(root, verifyingBlockService, { /* options */});\n    }\n}\nexport async function* unpackStream(readable, { roots, blockstore: userBlockstore } = {}) {\n    const carIterator = await CarBlockIterator.fromIterable(asAsyncIterable(readable));\n    const blockstore = userBlockstore || new MemoryBlockStore();\n    for await (const block of carIterator) {\n        await blockstore.put(block.cid, block.bytes);\n    }\n    const verifyingBlockStore = VerifyingGetOnlyBlockStore.fromBlockstore(blockstore);\n    if (!roots || roots.length === 0) {\n        roots = await carIterator.getRoots();\n    }\n    for (const root of roots) {\n        yield* unixFsExporter(root, verifyingBlockStore);\n    }\n}\n/**\n * Upgrade a ReadableStream to an AsyncIterable if it isn't already\n *\n * ReadableStream (e.g res.body) is asyncIterable in node, but not in chrome, yet.\n * see: https://bugs.chromium.org/p/chromium/issues/detail?id=929585\n */\nfunction asAsyncIterable(readable) {\n    // @ts-ignore how to convince tsc that we are checking the type here?\n    return Symbol.asyncIterator in readable ? readable : toIterable(readable);\n}\n"],"mappings":"AAAA,OAAOA,UAAU,MAAM,8BAA8B;AACrD,SAASC,gBAAgB,QAAQ,oBAAoB;AACrD,SAASC,SAAS,IAAIC,cAAc,QAAQ,sBAAsB;AAClE,SAASC,0BAA0B,QAAQ,0CAA0C;AACrF,SAASC,gBAAgB,QAAQ,yBAAyB;AAC1D;AACA,OAAO,gBAAgBC,MAAM,CAACC,SAAS,EAAEC,KAAK,EAAE;EAC5C,MAAMC,qBAAqB,GAAGL,0BAA0B,CAACM,aAAa,CAACH,SAAS,CAAC;EACjF,IAAI,CAACC,KAAK,IAAIA,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;IAC9BH,KAAK,GAAG,MAAMD,SAAS,CAACK,QAAQ,EAAE;EACtC;EACA,KAAK,MAAMC,IAAI,IAAIL,KAAK,EAAE;IACtB,OAAOL,cAAc,CAACU,IAAI,EAAEJ,qBAAqB,EAAE,CAAE,cAAc,CAAC;EACxE;AACJ;AACA,OAAO,gBAAgBK,YAAY,CAACC,QAAQ,EAAE;EAAEP,KAAK;EAAEQ,UAAU,EAAEC;AAAe,CAAC,GAAG,CAAC,CAAC,EAAE;EACtF,MAAMC,WAAW,GAAG,MAAMjB,gBAAgB,CAACkB,YAAY,CAACC,eAAe,CAACL,QAAQ,CAAC,CAAC;EAClF,MAAMC,UAAU,GAAGC,cAAc,IAAI,IAAIZ,gBAAgB,EAAE;EAC3D,WAAW,MAAMgB,KAAK,IAAIH,WAAW,EAAE;IACnC,MAAMF,UAAU,CAACM,GAAG,CAACD,KAAK,CAACE,GAAG,EAAEF,KAAK,CAACG,KAAK,CAAC;EAChD;EACA,MAAMC,mBAAmB,GAAGrB,0BAA0B,CAACsB,cAAc,CAACV,UAAU,CAAC;EACjF,IAAI,CAACR,KAAK,IAAIA,KAAK,CAACG,MAAM,KAAK,CAAC,EAAE;IAC9BH,KAAK,GAAG,MAAMU,WAAW,CAACN,QAAQ,EAAE;EACxC;EACA,KAAK,MAAMC,IAAI,IAAIL,KAAK,EAAE;IACtB,OAAOL,cAAc,CAACU,IAAI,EAAEY,mBAAmB,CAAC;EACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASL,eAAe,CAACL,QAAQ,EAAE;EAC/B;EACA,OAAOY,MAAM,CAACC,aAAa,IAAIb,QAAQ,GAAGA,QAAQ,GAAGf,UAAU,CAACe,QAAQ,CAAC;AAC7E"},"metadata":{},"sourceType":"module","externalDependencies":[]}