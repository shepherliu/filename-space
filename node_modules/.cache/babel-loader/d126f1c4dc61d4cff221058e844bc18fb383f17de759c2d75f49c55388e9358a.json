{"ast":null,"code":"import errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport findShardCid from '../../utils/find-cid-in-shard.js';\nimport { decode } from '@ipld/dag-pb';\nimport contentFile from './content/file.js';\nimport contentDirectory from './content/directory.js';\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js';\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name);\n  return link && link.Hash;\n};\nconst contentExporters = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  }\n};\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options);\n  const node = decode(block);\n  let unixfs;\n  let next;\n  if (!name) {\n    name = cid.toString();\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  try {\n    unixfs = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (!path) {\n    path = name;\n  }\n  if (toResolve.length) {\n    let linkCid;\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      linkCid = await findShardCid(node, toResolve[0], blockstore);\n    } else {\n      linkCid = findLinkCid(node, toResolve[0]);\n    }\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND');\n    }\n    const nextName = toResolve.shift();\n    const nextPath = `${path}/${nextName}`;\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName || '',\n      path: nextPath\n    };\n  }\n  return {\n    entry: {\n      type: unixfs.isDirectory() ? 'directory' : 'file',\n      name,\n      path,\n      cid,\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore),\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  };\n};\nexport default unixFsResolver;","map":{"version":3,"names":["errCode","UnixFS","findShardCid","decode","contentFile","contentDirectory","contentHamtShardedDirectory","findLinkCid","node","name","link","Links","find","Name","Hash","contentExporters","raw","file","directory","metadata","cid","unixfs","path","resolve","depth","blockstore","symlink","unixFsResolver","toResolve","options","block","get","next","toString","Data","Error","unmarshal","err","length","linkCid","type","nextName","shift","nextPath","entry","isDirectory","content","size","fileSize"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js"],"sourcesContent":["import errCode from 'err-code';\nimport { UnixFS } from 'ipfs-unixfs';\nimport findShardCid from '../../utils/find-cid-in-shard.js';\nimport { decode } from '@ipld/dag-pb';\nimport contentFile from './content/file.js';\nimport contentDirectory from './content/directory.js';\nimport contentHamtShardedDirectory from './content/hamt-sharded-directory.js';\nconst findLinkCid = (node, name) => {\n  const link = node.Links.find(link => link.Name === name);\n  return link && link.Hash;\n};\nconst contentExporters = {\n  raw: contentFile,\n  file: contentFile,\n  directory: contentDirectory,\n  'hamt-sharded-directory': contentHamtShardedDirectory,\n  metadata: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  },\n  symlink: (cid, node, unixfs, path, resolve, depth, blockstore) => {\n    return () => [];\n  }\n};\nconst unixFsResolver = async (cid, name, path, toResolve, resolve, depth, blockstore, options) => {\n  const block = await blockstore.get(cid, options);\n  const node = decode(block);\n  let unixfs;\n  let next;\n  if (!name) {\n    name = cid.toString();\n  }\n  if (node.Data == null) {\n    throw errCode(new Error('no data in PBNode'), 'ERR_NOT_UNIXFS');\n  }\n  try {\n    unixfs = UnixFS.unmarshal(node.Data);\n  } catch (err) {\n    throw errCode(err, 'ERR_NOT_UNIXFS');\n  }\n  if (!path) {\n    path = name;\n  }\n  if (toResolve.length) {\n    let linkCid;\n    if (unixfs && unixfs.type === 'hamt-sharded-directory') {\n      linkCid = await findShardCid(node, toResolve[0], blockstore);\n    } else {\n      linkCid = findLinkCid(node, toResolve[0]);\n    }\n    if (!linkCid) {\n      throw errCode(new Error('file does not exist'), 'ERR_NOT_FOUND');\n    }\n    const nextName = toResolve.shift();\n    const nextPath = `${ path }/${ nextName }`;\n    next = {\n      cid: linkCid,\n      toResolve,\n      name: nextName || '',\n      path: nextPath\n    };\n  }\n  return {\n    entry: {\n      type: unixfs.isDirectory() ? 'directory' : 'file',\n      name,\n      path,\n      cid,\n      content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, blockstore),\n      unixfs,\n      depth,\n      node,\n      size: unixfs.fileSize()\n    },\n    next\n  };\n};\nexport default unixFsResolver;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}