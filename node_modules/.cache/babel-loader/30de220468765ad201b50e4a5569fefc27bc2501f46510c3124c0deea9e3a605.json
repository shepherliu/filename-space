{"ast":null,"code":"var encode_1 = encode;\nvar MSB = 128,\n  REST = 127,\n  MSBALL = ~REST,\n  INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128,\n  REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0,\n    offset = offset || 0,\n    shift = 0,\n    counter = offset,\n    b,\n    l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;","map":{"version":3,"names":["encode_1","encode","MSB","REST","MSBALL","INT","Math","pow","num","out","offset","oldOffset","bytes","decode","read","MSB$1","REST$1","buf","res","shift","counter","b","l","length","RangeError","N1","N2","N3","N4","N5","N6","N7","N8","N9","value","varint","encodingLength","_brrp_varint"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/multiformats/esm/vendor/varint.js"],"sourcesContent":["var encode_1 = encode;\nvar MSB = 128, REST = 127, MSBALL = ~REST, INT = Math.pow(2, 31);\nfunction encode(num, out, offset) {\n  out = out || [];\n  offset = offset || 0;\n  var oldOffset = offset;\n  while (num >= INT) {\n    out[offset++] = num & 255 | MSB;\n    num /= 128;\n  }\n  while (num & MSBALL) {\n    out[offset++] = num & 255 | MSB;\n    num >>>= 7;\n  }\n  out[offset] = num | 0;\n  encode.bytes = offset - oldOffset + 1;\n  return out;\n}\nvar decode = read;\nvar MSB$1 = 128, REST$1 = 127;\nfunction read(buf, offset) {\n  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;\n  do {\n    if (counter >= l) {\n      read.bytes = 0;\n      throw new RangeError('Could not decode varint');\n    }\n    b = buf[counter++];\n    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);\n    shift += 7;\n  } while (b >= MSB$1);\n  read.bytes = counter - offset;\n  return res;\n}\nvar N1 = Math.pow(2, 7);\nvar N2 = Math.pow(2, 14);\nvar N3 = Math.pow(2, 21);\nvar N4 = Math.pow(2, 28);\nvar N5 = Math.pow(2, 35);\nvar N6 = Math.pow(2, 42);\nvar N7 = Math.pow(2, 49);\nvar N8 = Math.pow(2, 56);\nvar N9 = Math.pow(2, 63);\nvar length = function (value) {\n  return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;\n};\nvar varint = {\n  encode: encode_1,\n  decode: decode,\n  encodingLength: length\n};\nvar _brrp_varint = varint;\nexport default _brrp_varint;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}