{"ast":null,"code":"\"use strict\";\n\n// Runtime header offsets\nrequire(\"core-js/modules/es.typed-array.find-last.js\");\nrequire(\"core-js/modules/es.typed-array.find-last-index.js\");\nrequire(\"core-js/modules/es.array.push.js\");\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = imports.env = imports.env || {};\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  };\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  };\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2:\n          return new Float32Array(buffer);\n        case 3:\n          return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0:\n          return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1:\n          return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2:\n          return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3:\n          return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);\n  }\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[ptr + ID_OFFSET >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true; while (id = getBase(id));\n    }\n    return false;\n  }\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table = baseModule.table || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(preInstantiate(imports || (imports = {})), await WebAssembly.instantiate(source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source), imports));\n}\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(preInstantiate(imports || (imports = {})), new WebAssembly.Instance(source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source), imports));\n}\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);\n  }\n  return postInstantiate(preInstantiate(imports || (imports = {})), (await WebAssembly.instantiateStreaming(source, imports)).instance);\n}\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"] ? function (length) {\n    exports[\"__argumentsLength\"].value = length;\n  } : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function () {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function (...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function (thisValue) {\n          return Object.create(ctor.prototype, {\n            [THIS]: {\n              value: thisValue,\n              writable: false\n            }\n          });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name => Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name)));\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function () {\n              return getter(this[THIS]);\n            },\n            set: function (value) {\n              setter(this[THIS], value);\n            },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else {\n          // instance method\n          (curr[name] = function (...args) {\n            // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\nexports.demangle = demangle;","map":{"version":3,"names":["ID_OFFSET","SIZE_OFFSET","ARRAYBUFFER_ID","STRING_ID","ARRAYBUFFERVIEW_ID","ARRAYBUFFERVIEW","ARRAY","SET","MAP","VAL_ALIGN_OFFSET","VAL_ALIGN","VAL_SIGNED","VAL_FLOAT","VAL_NULLABLE","VAL_MANAGED","KEY_ALIGN_OFFSET","KEY_ALIGN","KEY_SIGNED","KEY_FLOAT","KEY_NULLABLE","KEY_MANAGED","ARRAYBUFFERVIEW_BUFFER_OFFSET","ARRAYBUFFERVIEW_DATASTART_OFFSET","ARRAYBUFFERVIEW_DATALENGTH_OFFSET","ARRAYBUFFERVIEW_SIZE","ARRAY_LENGTH_OFFSET","ARRAY_SIZE","BIGINT","BigUint64Array","THIS","Symbol","CHUNKSIZE","getStringImpl","buffer","ptr","U32","Uint32Array","U16","Uint16Array","length","offset","String","fromCharCode","apply","subarray","parts","last","size","push","join","preInstantiate","imports","baseModule","getString","memory","env","abort","mesg","file","line","colm","Error","trace","n","console","log","Array","prototype","slice","call","arguments","Math","Date","postInstantiate","instance","rawExports","exports","table","alloc","retain","rttiBase","getInfo","id","count","getBase","getValueAlign","info","clz32","getKeyAlign","__allocString","str","i","p","charCodeAt","__getString","getView","alignLog2","signed","float","Float32Array","Float64Array","Int8Array","Uint8Array","Int16Array","Int32Array","BigInt64Array","__allocArray","values","align","buf","arr","view","set","__getArrayView","__getArray","input","len","out","__getArrayBuffer","getTypedArray","Type","getTypedArrayView","bufPtr","__getInt8Array","bind","__getInt8ArrayView","__getUint8Array","__getUint8ArrayView","__getUint8ClampedArray","Uint8ClampedArray","__getUint8ClampedArrayView","__getInt16Array","__getInt16ArrayView","__getUint16Array","__getUint16ArrayView","__getInt32Array","__getInt32ArrayView","__getUint32Array","__getUint32ArrayView","__getInt64Array","__getInt64ArrayView","__getUint64Array","__getUint64ArrayView","__getFloat32Array","__getFloat32ArrayView","__getFloat64Array","__getFloat64ArrayView","__instanceof","baseId","demangle","isResponse","o","Response","instantiate","source","instantiateStreaming","WebAssembly","Module","compile","instantiateSync","Instance","arrayBuffer","module","Object","create","setArgumentsLength","value","internalName","hasOwnProperty","elem","split","curr","part","shift","name","hash","indexOf","className","substring","classElem","ctor","args","wrap","constructor","valueOf","thisValue","writable","getOwnPropertyNames","forEach","defineProperty","getOwnPropertyDescriptor","test","getter","replace","setter","get","enumerable","original"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/@assemblyscript/loader/index.js"],"sourcesContent":["\"use strict\";\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}