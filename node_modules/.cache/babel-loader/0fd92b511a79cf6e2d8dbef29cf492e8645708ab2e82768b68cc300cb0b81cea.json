{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hasProvider = exports.ZnsSupportedNetwork = exports.UnsSupportedNetwork = exports.NullAddresses = exports.NullAddress = void 0;\nexports.NullAddress = '0x0000000000000000000000000000000000000000';\nvar NullAddresses;\n(function (NullAddresses) {\n  NullAddresses[NullAddresses[\"0x\"] = 0] = \"0x\";\n  NullAddresses[NullAddresses[\"0x0000000000000000000000000000000000000000\"] = 1] = \"0x0000000000000000000000000000000000000000\";\n  NullAddresses[NullAddresses[\"0x0000000000000000000000000000000000000000000000000000000000000000\"] = 2] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n})(NullAddresses = exports.NullAddresses || (exports.NullAddresses = {}));\n// TypeScript will infer a string union type from the literal values passed to\n// this function. Without `extends string`, it would instead generalize them\n// to the common string type.\n// @see https://stackoverflow.com/questions/36836011/checking-validity-of-string-literal-union-type-at-runtime\nvar StringUnion = function () {\n  var values = [];\n  for (var _i = 0; _i < arguments.length; _i++) {\n    values[_i] = arguments[_i];\n  }\n  Object.freeze(values);\n  var valueSet = new Set(values);\n  var guard = function (value) {\n    return valueSet.has(value);\n  };\n  var check = function (value) {\n    if (!guard(value)) {\n      var actual = JSON.stringify(value);\n      var expected = values.map(function (s) {\n        return JSON.stringify(s);\n      }).join(' | ');\n      throw new TypeError(\"Value '\".concat(actual, \"' is not assignable to type '\").concat(expected, \"'.\"));\n    }\n    return value;\n  };\n  var unionNamespace = {\n    guard: guard,\n    check: check,\n    values: values\n  };\n  return Object.freeze(unionNamespace);\n};\nexports.UnsSupportedNetwork = StringUnion('mainnet', 'rinkeby', 'goerli', 'polygon-mainnet', 'polygon-mumbai');\nexports.ZnsSupportedNetwork = StringUnion('mainnet', 'testnet');\nfunction hasProvider(obj) {\n  return obj && !!obj.provider;\n}\nexports.hasProvider = hasProvider;","map":{"version":3,"names":["Object","defineProperty","exports","value","hasProvider","ZnsSupportedNetwork","UnsSupportedNetwork","NullAddresses","NullAddress","StringUnion","values","_i","arguments","length","freeze","valueSet","Set","guard","has","check","actual","JSON","stringify","expected","map","s","join","TypeError","concat","unionNamespace","obj","provider"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/@unstoppabledomains/resolution/build/types/index.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hasProvider = exports.ZnsSupportedNetwork = exports.UnsSupportedNetwork = exports.NullAddresses = exports.NullAddress = void 0;\nexports.NullAddress = '0x0000000000000000000000000000000000000000';\nvar NullAddresses;\n(function (NullAddresses) {\n    NullAddresses[NullAddresses[\"0x\"] = 0] = \"0x\";\n    NullAddresses[NullAddresses[\"0x0000000000000000000000000000000000000000\"] = 1] = \"0x0000000000000000000000000000000000000000\";\n    NullAddresses[NullAddresses[\"0x0000000000000000000000000000000000000000000000000000000000000000\"] = 2] = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n})(NullAddresses = exports.NullAddresses || (exports.NullAddresses = {}));\n// TypeScript will infer a string union type from the literal values passed to\n// this function. Without `extends string`, it would instead generalize them\n// to the common string type.\n// @see https://stackoverflow.com/questions/36836011/checking-validity-of-string-literal-union-type-at-runtime\nvar StringUnion = function () {\n    var values = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        values[_i] = arguments[_i];\n    }\n    Object.freeze(values);\n    var valueSet = new Set(values);\n    var guard = function (value) {\n        return valueSet.has(value);\n    };\n    var check = function (value) {\n        if (!guard(value)) {\n            var actual = JSON.stringify(value);\n            var expected = values.map(function (s) { return JSON.stringify(s); }).join(' | ');\n            throw new TypeError(\"Value '\".concat(actual, \"' is not assignable to type '\").concat(expected, \"'.\"));\n        }\n        return value;\n    };\n    var unionNamespace = { guard: guard, check: check, values: values };\n    return Object.freeze(unionNamespace);\n};\nexports.UnsSupportedNetwork = StringUnion('mainnet', 'rinkeby', 'goerli', 'polygon-mainnet', 'polygon-mumbai');\nexports.ZnsSupportedNetwork = StringUnion('mainnet', 'testnet');\nfunction hasProvider(obj) {\n    return obj && !!obj.provider;\n}\nexports.hasProvider = hasProvider;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,WAAW,GAAGF,OAAO,CAACG,mBAAmB,GAAGH,OAAO,CAACI,mBAAmB,GAAGJ,OAAO,CAACK,aAAa,GAAGL,OAAO,CAACM,WAAW,GAAG,KAAK,CAAC;AACtIN,OAAO,CAACM,WAAW,GAAG,4CAA4C;AAClE,IAAID,aAAa;AACjB,CAAC,UAAUA,aAAa,EAAE;EACtBA,aAAa,CAACA,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,IAAI;EAC7CA,aAAa,CAACA,aAAa,CAAC,4CAA4C,CAAC,GAAG,CAAC,CAAC,GAAG,4CAA4C;EAC7HA,aAAa,CAACA,aAAa,CAAC,oEAAoE,CAAC,GAAG,CAAC,CAAC,GAAG,oEAAoE;AACjL,CAAC,EAAEA,aAAa,GAAGL,OAAO,CAACK,aAAa,KAAKL,OAAO,CAACK,aAAa,GAAG,CAAC,CAAC,CAAC,CAAC;AACzE;AACA;AACA;AACA;AACA,IAAIE,WAAW,GAAG,YAAY;EAC1B,IAAIC,MAAM,GAAG,EAAE;EACf,KAAK,IAAIC,EAAE,GAAG,CAAC,EAAEA,EAAE,GAAGC,SAAS,CAACC,MAAM,EAAEF,EAAE,EAAE,EAAE;IAC1CD,MAAM,CAACC,EAAE,CAAC,GAAGC,SAAS,CAACD,EAAE,CAAC;EAC9B;EACAX,MAAM,CAACc,MAAM,CAACJ,MAAM,CAAC;EACrB,IAAIK,QAAQ,GAAG,IAAIC,GAAG,CAACN,MAAM,CAAC;EAC9B,IAAIO,KAAK,GAAG,UAAUd,KAAK,EAAE;IACzB,OAAOY,QAAQ,CAACG,GAAG,CAACf,KAAK,CAAC;EAC9B,CAAC;EACD,IAAIgB,KAAK,GAAG,UAAUhB,KAAK,EAAE;IACzB,IAAI,CAACc,KAAK,CAACd,KAAK,CAAC,EAAE;MACf,IAAIiB,MAAM,GAAGC,IAAI,CAACC,SAAS,CAACnB,KAAK,CAAC;MAClC,IAAIoB,QAAQ,GAAGb,MAAM,CAACc,GAAG,CAAC,UAAUC,CAAC,EAAE;QAAE,OAAOJ,IAAI,CAACC,SAAS,CAACG,CAAC,CAAC;MAAE,CAAC,CAAC,CAACC,IAAI,CAAC,KAAK,CAAC;MACjF,MAAM,IAAIC,SAAS,CAAC,SAAS,CAACC,MAAM,CAACR,MAAM,EAAE,+BAA+B,CAAC,CAACQ,MAAM,CAACL,QAAQ,EAAE,IAAI,CAAC,CAAC;IACzG;IACA,OAAOpB,KAAK;EAChB,CAAC;EACD,IAAI0B,cAAc,GAAG;IAAEZ,KAAK,EAAEA,KAAK;IAAEE,KAAK,EAAEA,KAAK;IAAET,MAAM,EAAEA;EAAO,CAAC;EACnE,OAAOV,MAAM,CAACc,MAAM,CAACe,cAAc,CAAC;AACxC,CAAC;AACD3B,OAAO,CAACI,mBAAmB,GAAGG,WAAW,CAAC,SAAS,EAAE,SAAS,EAAE,QAAQ,EAAE,iBAAiB,EAAE,gBAAgB,CAAC;AAC9GP,OAAO,CAACG,mBAAmB,GAAGI,WAAW,CAAC,SAAS,EAAE,SAAS,CAAC;AAC/D,SAASL,WAAW,CAAC0B,GAAG,EAAE;EACtB,OAAOA,GAAG,IAAI,CAAC,CAACA,GAAG,CAACC,QAAQ;AAChC;AACA7B,OAAO,CAACE,WAAW,GAAGA,WAAW"},"metadata":{},"sourceType":"script","externalDependencies":[]}