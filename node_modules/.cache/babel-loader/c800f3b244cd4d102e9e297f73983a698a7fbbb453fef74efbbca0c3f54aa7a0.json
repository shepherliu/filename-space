{"ast":null,"code":"import \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid = CID.asCID(path);\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode(new Error(`Unknown path type ${path}`), 'ERR_BAD_PATH');\n};\nexport async function* walkPath(path, blockstore, options = {}) {\n  let {\n    cid,\n    toResolve\n  } = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n    }\n    if (result.entry) {\n      yield result.entry;\n    }\n    if (!result.next) {\n      return;\n    }\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\nexport async function exporter(path, blockstore, options = {}) {\n  const result = await last(walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${path}`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\nexport async function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n  if (!node) {\n    return;\n  }\n  yield node;\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}","map":{"version":3,"names":["errCode","CID","resolve","last","toPathComponents","path","trim","match","filter","Boolean","cidAndRest","Uint8Array","cid","decode","toResolve","asCID","indexOf","substring","output","parse","slice","Error","walkPath","blockstore","options","name","toString","entryPath","startingDepth","length","result","entry","next","exporter","recursive","node","type","child","recurse","file","content"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/ipfs-unixfs-exporter/esm/src/index.js"],"sourcesContent":["import errCode from 'err-code';\nimport { CID } from 'multiformats/cid';\nimport resolve from './resolvers/index.js';\nimport last from 'it-last';\nconst toPathComponents = (path = '') => {\n  return (path.trim().match(/([^\\\\^/]|\\\\\\/)+/g) || []).filter(Boolean);\n};\nconst cidAndRest = path => {\n  if (path instanceof Uint8Array) {\n    return {\n      cid: CID.decode(path),\n      toResolve: []\n    };\n  }\n  const cid = CID.asCID(path);\n  if (cid) {\n    return {\n      cid,\n      toResolve: []\n    };\n  }\n  if (typeof path === 'string') {\n    if (path.indexOf('/ipfs/') === 0) {\n      path = path.substring(6);\n    }\n    const output = toPathComponents(path);\n    return {\n      cid: CID.parse(output[0]),\n      toResolve: output.slice(1)\n    };\n  }\n  throw errCode(new Error(`Unknown path type ${ path }`), 'ERR_BAD_PATH');\n};\nexport async function* walkPath(path, blockstore, options = {}) {\n  let {cid, toResolve} = cidAndRest(path);\n  let name = cid.toString();\n  let entryPath = name;\n  const startingDepth = toResolve.length;\n  while (true) {\n    const result = await resolve(cid, name, entryPath, toResolve, startingDepth, blockstore, options);\n    if (!result.entry && !result.next) {\n      throw errCode(new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n    }\n    if (result.entry) {\n      yield result.entry;\n    }\n    if (!result.next) {\n      return;\n    }\n    toResolve = result.next.toResolve;\n    cid = result.next.cid;\n    name = result.next.name;\n    entryPath = result.next.path;\n  }\n}\nexport async function exporter(path, blockstore, options = {}) {\n  const result = await last(walkPath(path, blockstore, options));\n  if (!result) {\n    throw errCode(new Error(`Could not resolve ${ path }`), 'ERR_NOT_FOUND');\n  }\n  return result;\n}\nexport async function* recursive(path, blockstore, options = {}) {\n  const node = await exporter(path, blockstore, options);\n  if (!node) {\n    return;\n  }\n  yield node;\n  if (node.type === 'directory') {\n    for await (const child of recurse(node, options)) {\n      yield child;\n    }\n  }\n  async function* recurse(node, options) {\n    for await (const file of node.content(options)) {\n      yield file;\n      if (file instanceof Uint8Array) {\n        continue;\n      }\n      if (file.type === 'directory') {\n        yield* recurse(file, options);\n      }\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}