{"ast":null,"code":"import \"core-js/modules/es.typed-array.find-last.js\";\nimport \"core-js/modules/es.typed-array.find-last-index.js\";\nimport * as cborg from 'cborg';\nimport { CID } from 'multiformats/cid';\nconst CID_CBOR_TAG = 42;\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  const cid = CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1);\n  return [new cborg.Token(cborg.Type.tag, CID_CBOR_TAG), new cborg.Token(cborg.Type.bytes, bytes)];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n  return CID.decode(bytes.subarray(1));\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nexport const name = 'dag-cbor';\nexport const code = 113;\nexport const encode = node => cborg.encode(node, encodeOptions);\nexport const decode = data => cborg.decode(data, decodeOptions);","map":{"version":3,"names":["cborg","CID","CID_CBOR_TAG","cidEncoder","obj","asCID","cid","bytes","Uint8Array","byteLength","set","Token","Type","tag","undefinedEncoder","Error","numberEncoder","num","Number","isNaN","Infinity","encodeOptions","float64","typeEncoders","Object","undefined","number","cidDecoder","decode","subarray","decodeOptions","allowIndefinite","allowUndefined","allowNaN","allowInfinity","allowBigInt","strict","useMaps","tags","name","code","encode","node","data"],"sources":["/Users/shepher/Downloads/filename-space/node_modules/carbites/node_modules/@ipld/dag-cbor/esm/index.js"],"sourcesContent":["import * as cborg from 'cborg';\nimport { CID } from 'multiformats/cid';\nconst CID_CBOR_TAG = 42;\nfunction cidEncoder(obj) {\n  if (obj.asCID !== obj) {\n    return null;\n  }\n  const cid = CID.asCID(obj);\n  if (!cid) {\n    return null;\n  }\n  const bytes = new Uint8Array(cid.bytes.byteLength + 1);\n  bytes.set(cid.bytes, 1);\n  return [\n    new cborg.Token(cborg.Type.tag, CID_CBOR_TAG),\n    new cborg.Token(cborg.Type.bytes, bytes)\n  ];\n}\nfunction undefinedEncoder() {\n  throw new Error('`undefined` is not supported by the IPLD Data Model and cannot be encoded');\n}\nfunction numberEncoder(num) {\n  if (Number.isNaN(num)) {\n    throw new Error('`NaN` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  if (num === Infinity || num === -Infinity) {\n    throw new Error('`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded');\n  }\n  return null;\n}\nconst encodeOptions = {\n  float64: true,\n  typeEncoders: {\n    Object: cidEncoder,\n    undefined: undefinedEncoder,\n    number: numberEncoder\n  }\n};\nfunction cidDecoder(bytes) {\n  if (bytes[0] !== 0) {\n    throw new Error('Invalid CID for CBOR tag 42; expected leading 0x00');\n  }\n  return CID.decode(bytes.subarray(1));\n}\nconst decodeOptions = {\n  allowIndefinite: false,\n  allowUndefined: false,\n  allowNaN: false,\n  allowInfinity: false,\n  allowBigInt: true,\n  strict: true,\n  useMaps: false,\n  tags: []\n};\ndecodeOptions.tags[CID_CBOR_TAG] = cidDecoder;\nexport const name = 'dag-cbor';\nexport const code = 113;\nexport const encode = node => cborg.encode(node, encodeOptions);\nexport const decode = data => cborg.decode(data, decodeOptions);"],"mappings":";;AAAA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,SAASC,GAAG,QAAQ,kBAAkB;AACtC,MAAMC,YAAY,GAAG,EAAE;AACvB,SAASC,UAAU,CAACC,GAAG,EAAE;EACvB,IAAIA,GAAG,CAACC,KAAK,KAAKD,GAAG,EAAE;IACrB,OAAO,IAAI;EACb;EACA,MAAME,GAAG,GAAGL,GAAG,CAACI,KAAK,CAACD,GAAG,CAAC;EAC1B,IAAI,CAACE,GAAG,EAAE;IACR,OAAO,IAAI;EACb;EACA,MAAMC,KAAK,GAAG,IAAIC,UAAU,CAACF,GAAG,CAACC,KAAK,CAACE,UAAU,GAAG,CAAC,CAAC;EACtDF,KAAK,CAACG,GAAG,CAACJ,GAAG,CAACC,KAAK,EAAE,CAAC,CAAC;EACvB,OAAO,CACL,IAAIP,KAAK,CAACW,KAAK,CAACX,KAAK,CAACY,IAAI,CAACC,GAAG,EAAEX,YAAY,CAAC,EAC7C,IAAIF,KAAK,CAACW,KAAK,CAACX,KAAK,CAACY,IAAI,CAACL,KAAK,EAAEA,KAAK,CAAC,CACzC;AACH;AACA,SAASO,gBAAgB,GAAG;EAC1B,MAAM,IAAIC,KAAK,CAAC,2EAA2E,CAAC;AAC9F;AACA,SAASC,aAAa,CAACC,GAAG,EAAE;EAC1B,IAAIC,MAAM,CAACC,KAAK,CAACF,GAAG,CAAC,EAAE;IACrB,MAAM,IAAIF,KAAK,CAAC,qEAAqE,CAAC;EACxF;EACA,IAAIE,GAAG,KAAKG,QAAQ,IAAIH,GAAG,KAAK,CAACG,QAAQ,EAAE;IACzC,MAAM,IAAIL,KAAK,CAAC,0FAA0F,CAAC;EAC7G;EACA,OAAO,IAAI;AACb;AACA,MAAMM,aAAa,GAAG;EACpBC,OAAO,EAAE,IAAI;EACbC,YAAY,EAAE;IACZC,MAAM,EAAErB,UAAU;IAClBsB,SAAS,EAAEX,gBAAgB;IAC3BY,MAAM,EAAEV;EACV;AACF,CAAC;AACD,SAASW,UAAU,CAACpB,KAAK,EAAE;EACzB,IAAIA,KAAK,CAAC,CAAC,CAAC,KAAK,CAAC,EAAE;IAClB,MAAM,IAAIQ,KAAK,CAAC,oDAAoD,CAAC;EACvE;EACA,OAAOd,GAAG,CAAC2B,MAAM,CAACrB,KAAK,CAACsB,QAAQ,CAAC,CAAC,CAAC,CAAC;AACtC;AACA,MAAMC,aAAa,GAAG;EACpBC,eAAe,EAAE,KAAK;EACtBC,cAAc,EAAE,KAAK;EACrBC,QAAQ,EAAE,KAAK;EACfC,aAAa,EAAE,KAAK;EACpBC,WAAW,EAAE,IAAI;EACjBC,MAAM,EAAE,IAAI;EACZC,OAAO,EAAE,KAAK;EACdC,IAAI,EAAE;AACR,CAAC;AACDR,aAAa,CAACQ,IAAI,CAACpC,YAAY,CAAC,GAAGyB,UAAU;AAC7C,OAAO,MAAMY,IAAI,GAAG,UAAU;AAC9B,OAAO,MAAMC,IAAI,GAAG,GAAG;AACvB,OAAO,MAAMC,MAAM,GAAGC,IAAI,IAAI1C,KAAK,CAACyC,MAAM,CAACC,IAAI,EAAErB,aAAa,CAAC;AAC/D,OAAO,MAAMO,MAAM,GAAGe,IAAI,IAAI3C,KAAK,CAAC4B,MAAM,CAACe,IAAI,EAAEb,aAAa,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}